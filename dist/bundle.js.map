{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap eea905c8843398bbafa7","webpack:///./~/riot/riot.js","webpack:///./src/scripts/data.js","webpack:///./src/components/div-bars/stacked-barh.tag","webpack:///./src/components/div-bars/stacked-barhs.tag","webpack:///./src/components/industries-main.tag","webpack:///./src/components/industries-multi-charts.tag","webpack:///./src/components/industry-chart/industry-chart.tag","webpack:///./src/scripts/index.js","webpack:///./src/scripts/lib/d3.js","webpack:///./src/scripts/mixins/class_name.js","webpack:///./src/scripts/mixins/number_format.js","webpack:///./~/d3-format/build/d3-format.js","webpack:///./src/data/smamu_industries.csv","webpack:///./src/data/top_industries.csv","webpack:///./src/data/industry_stories.json","webpack:///./src/data/smamu_groups.json"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","riot","global","factory","this","isBoolAttr","value","RE_BOOL_ATTRS","test","isFunction","T_FUNCTION","isObject","T_OBJECT","isUndefined","T_UNDEF","isString","T_STRING","isBlank","isArray","Array","isWritable","obj","key","descriptor","Object","getOwnPropertyDescriptor","writable","isReservedName","RE_RESERVED_NAMES","$$","selector","ctx","prototype","slice","document","querySelectorAll","$","querySelector","createFrag","createDocumentFragment","createDOMPlaceholder","createTextNode","isSvg","el","ownerSVGElement","mkEl","name","createElementNS","SVG_NS","createElement","setInnerHTML","container","html","innerHTML","doc","DOMParser","parseFromString","node","ownerDocument","importNode","documentElement","appendChild","toggleVisibility","dom","show","style","display","remAttr","removeAttribute","styleObjectToString","keys","reduce","acc","prop","getAttr","getAttribute","setAttr","val","xlink","XLINK_REGEX","exec","setAttributeNS","XLINK_NS","setAttribute","safeInsert","root","curr","next","insertBefore","parentNode","walkAttrs","fn","RE_HTML_ATTRS","toLowerCase","walkNodes","context","res","firstChild","nextSibling","each","list","len","length","i","contains","array","item","indexOf","toCamel","str","replace","_","toUpperCase","startsWith","defineProperty","options","extend","enumerable","configurable","src","args","arguments","handleEvent","handler","e","ptag","__","parent","currentTarget","target","srcElement","which","charCode","keyCode","settings$1","autoUpdate","preventUpdate","getImmediateCustomParentTag","isMounted","update","setEventHandler","tag","eventName","cb","bind","RE_EVENTS_PREFIX","listeners","push","RIOT_EVENTS_KEY","removeEventListener","addEventListener","updateDataIs","expr","tagName","conf","isVirtual","head","ref","unmount","impl","__TAG_IMPL","hasImpl","initChildTag","attrs","a","mount","makeReplaceVirtual","onUnmount","delName","opts","dataIs","tags","_tags","arrayishRemove","normalizeAttrName","attrName","ATTRS_PREFIX","CASE_SENSITIVE_ATTRIBUTES","updateExpression","hasValue","isObj","attr","isToggle","SHOW_DIRECTIVE","HIDE_DIRECTIVE","isStyleAttr","isClassAttr","_riot_id","tmpl","create","JSON","stringify","isAttrRemoved","bool","isRtag","wasParsedOnce","hidden","IE_VERSION","nodeValue","updateAllExpressions","expressions","mkitem","base","pos","unmountRedundant","items","j","remove","apply","splice","moveNestedTags","this$1","moveChildTag","move","nextTag","moveVirtual","insert","makeVirtual","append","_each","LOOP_DIRECTIVE","hasKeys","mustReorder","LOOP_NO_REORDER_DIRECTIVE","getTagName","placeholder","child","getTag","ifExpr","CONDITIONAL_DIRECTIVE","oldItems","isLoop","isAnonymous","loopKeys","removeChild","frag","isObject$$1","map","filter","doReorder","oldPos","isNew","mustAppend","mustCreate","Tag$1","cloneNode","index","arrayishAdd","t","parseExpressions","mustIncludeRoot","tree","children","tagImpl","type","nodeType","hasExpr","IfExpr","init","IS_DIRECTIVE","attributes","parentElement","outerHTML","parseAttributes","REF_DIRECTIVES","RefExpr","specialTags","select","trim","selectedIndex","tname","rootEls","childElementCount","replaceYield","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","mkdom","isSvg$$1","match","SVG","GENERIC","tblTags","Tag$2","css","onCreate","tag$1","class","constructor","mountTo","styleManager","inject","add","tag2$1","mount$1","pushTagsTo","riotTag","elem","allTags","selectTags","split","nodeList","_el","mixin$1","mix","g","mixins_id","store","globals","mixins","Error","update$1","__TAGS_CACHE","unregister$1","updateOpts","instAttrs","skipAnonymous","skipAnonymousTags","cleanUpData","implAttrs","isInline","propsInSyncWithParent","observable$1","_tag","virts","tail","__uid","data","nextOpts","canTrigger","shouldUpdate","inheritFrom","trigger","instance","props","propsBlacklist","proto","getPrototypeOf","concat","getOwnPropertyNames","hasGetterSetter","get","set","hasOwnProperty","isPrototypeOf","k","v","globalMixin","GLOBAL_MIXIN","mixin","one","mustKeepRoot","tagIndex","forEach","unmountAll","off","mustSync","newPos","skipDataIs","namedTag","o","ensureArray","dest","isArr","hasIndex","oldIndex","implClass","_innerHTML","replaceChild","sib","styleNode","cssTextProp","WIN","window","undefined","RE_SPECIAL_TAGS","RE_SPECIAL_TAGS_NO_OPTION","viewbox","documentMode","check","freeze","byName","remainder","needsInject","newNode","userNode","getElementsByTagName","styleSheet","join","cssText","skipRegex","prev","code","_skipRegex","start","re","lastIndex","RE_REGEX","beforeReChars","RE_VN_CHAR","wordsLastChar","end","beforeReWords","s","w","brackets","UNDEF","_loopback","_rewrite","bp","_cache","RegExp","source","REGLOB","_create","pair","DEFAULT","_pairs","arr","UNSUPPORTED","NEED_ESCAPE","S_QBLOCK2","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","b","_settings","R_MLCOMMS","R_STRINGS","S_QBLOCKS","FINDBRACES","(","[","{","_bp","unescapeStr","prevStr","isexpr","parts","pushQBlock","_pos","_lastIndex","slash","mark","qblocks","ch","rech","ix","settings","_tmpl","_logErr","err","riotData","errorHandler","console","error","message","log","_getTmpl","Function","RE_DQUOTE","qstr","_parseExpr","RE_QBMARK","asText","skipBraces","mm","lv","ir","RE_BREND","cnt","RE_CSNAME","jsb","rightContext","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","clearCache","version","callbacks","defineProperties","on","event","fns","arguments$1","arglen","misc","stub","pristine","current","attrValue","rawValue","hasExp","old","customParent","tagOrDom","__ref","refs","tr","th","td","col","version$1","core","Tag","tag2","unregister","util","vdom","Tag$$1","tag$$1","tag2$$1","mount$$1","mixin$$1","update$$1","unregister$$1","version$$1","observable","riot$1","topIndustries","smamuIndustries","smamuGroups","industryStories","_this","getData","cols","label","labelformat","modifier","modifiers","_data","sort","gb_t_rel","_f","groups","labels","getDesc","getValue","_ref","suffix","field","_ref2","_interopRequireDefault","__esModule","default","_class_name","_class_name2","_number_format","_number_format2","_d3Format","format","formatLocale","cssNamespace","getClass","mod","part","cssClass","_interopRequireWildcard","newObj","_d","d3","loc","thousands","decimal","grouping","formatSpecifier","specifier","FormatSpecifier","fill","align","sign","symbol","zero","width","comma","precision","formatTypes","defaultLocale","definition","locale","formatPrefix","prefixExponent","formatDecimal","x","toExponential","coefficient","exponent","Math","abs","NaN","formatGroup","max","substring","reverse","formatNumerals","numerals","formatDefault","toPrecision","out","i1","n","i0","formatPrefixAuto","d","min","floor","formatRounded","","%","toFixed","round","toString","f","r","X","identity","prefixes","newFormat","valuePrefix","prefix","valueSuffix","formatType","valueNegative","maybeSuffix","charCodeAt","group","Infinity","padding","currency","percent","pow","precisionFixed","step","precisionPrefix","precisionRound","formatDefaultLocale","svb_f","gb_f","svb_foreign","gb_foreign","svb_assistant","gb_assistant","svb_education","gb_education","columns","svb_t_relv","gb_t_relv","svb_t_rel","svb_t","gb_t","Einzelhandel (ohne KFZ)","Gastronomie","Geb√§udebetreuung, Garten- und Landschaftsbau","Gesundheitswesen","Private Haushalte mit Hauspersonal","Baustellenarbeiten, Bauinstallation etc.","title"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(8);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {/* Riot v3.6.1, @license MIT */\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.riot = global.riot || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tvar __TAGS_CACHE = [];\n\tvar __TAG_IMPL = {};\n\tvar GLOBAL_MIXIN = '__global_mixin';\n\tvar ATTRS_PREFIX = 'riot-';\n\tvar REF_DIRECTIVES = ['ref', 'data-ref'];\n\tvar IS_DIRECTIVE = 'data-is';\n\tvar CONDITIONAL_DIRECTIVE = 'if';\n\tvar LOOP_DIRECTIVE = 'each';\n\tvar LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\n\tvar SHOW_DIRECTIVE = 'show';\n\tvar HIDE_DIRECTIVE = 'hide';\n\tvar RIOT_EVENTS_KEY = '__riot-events__';\n\tvar T_STRING = 'string';\n\tvar T_OBJECT = 'object';\n\tvar T_UNDEF  = 'undefined';\n\tvar T_FUNCTION = 'function';\n\tvar XLINK_NS = 'http://www.w3.org/1999/xlink';\n\tvar SVG_NS = 'http://www.w3.org/2000/svg';\n\tvar XLINK_REGEX = /^xlink:(\\w+)/;\n\tvar WIN = typeof window === T_UNDEF ? undefined : window;\n\tvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\n\tvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\n\tvar RE_EVENTS_PREFIX = /^on/;\n\tvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\n\tvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\n\tvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\n\tvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\n\tvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\t\n\t/**\n\t * Check Check if the passed argument is undefined\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBoolAttr(value) {\n\t  return RE_BOOL_ATTRS.test(value)\n\t}\n\t\n\t/**\n\t * Check if passed argument is a function\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isFunction(value) {\n\t  return typeof value === T_FUNCTION\n\t}\n\t\n\t/**\n\t * Check if passed argument is an object, exclude null\n\t * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isObject(value) {\n\t  return value && typeof value === T_OBJECT // typeof null is 'object'\n\t}\n\t\n\t/**\n\t * Check if passed argument is undefined\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isUndefined(value) {\n\t  return typeof value === T_UNDEF\n\t}\n\t\n\t/**\n\t * Check if passed argument is a string\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isString(value) {\n\t  return typeof value === T_STRING\n\t}\n\t\n\t/**\n\t * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n\t * @param { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBlank(value) {\n\t  return isUndefined(value) || value === null || value === ''\n\t}\n\t\n\t/**\n\t * Check if passed argument is a kind of array\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isArray(value) {\n\t  return Array.isArray(value) || value instanceof Array\n\t}\n\t\n\t/**\n\t * Check whether object's property could be overridden\n\t * @param   { Object }  obj - source object\n\t * @param   { String }  key - object property\n\t * @returns { Boolean } -\n\t */\n\tfunction isWritable(obj, key) {\n\t  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\t  return isUndefined(obj[key]) || descriptor && descriptor.writable\n\t}\n\t\n\t/**\n\t * Check if passed argument is a reserved name\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isReservedName(value) {\n\t  return RE_RESERVED_NAMES.test(value)\n\t}\n\t\n\tvar check = Object.freeze({\n\t\tisBoolAttr: isBoolAttr,\n\t\tisFunction: isFunction,\n\t\tisObject: isObject,\n\t\tisUndefined: isUndefined,\n\t\tisString: isString,\n\t\tisBlank: isBlank,\n\t\tisArray: isArray,\n\t\tisWritable: isWritable,\n\t\tisReservedName: isReservedName\n\t});\n\t\n\t/**\n\t * Shorter and fast way to select multiple nodes in the DOM\n\t * @param   { String } selector - DOM selector\n\t * @param   { Object } ctx - DOM node where the targets of our search will is located\n\t * @returns { Object } dom nodes found\n\t */\n\tfunction $$(selector, ctx) {\n\t  return Array.prototype.slice.call((ctx || document).querySelectorAll(selector))\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select a single node in the DOM\n\t * @param   { String } selector - unique dom selector\n\t * @param   { Object } ctx - DOM node where the target of our search will is located\n\t * @returns { Object } dom node found\n\t */\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\t/**\n\t * Create a document fragment\n\t * @returns { Object } document fragment\n\t */\n\tfunction createFrag() {\n\t  return document.createDocumentFragment()\n\t}\n\t\n\t/**\n\t * Create a document text node\n\t * @returns { Object } create a text node to use as placeholder\n\t */\n\tfunction createDOMPlaceholder() {\n\t  return document.createTextNode('')\n\t}\n\t\n\t/**\n\t * Check if a DOM node is an svg tag\n\t * @param   { HTMLElement }  el - node we want to test\n\t * @returns {Boolean} true if it's an svg node\n\t */\n\tfunction isSvg(el) {\n\t  return !!el.ownerSVGElement\n\t}\n\t\n\t/**\n\t * Create a generic DOM node\n\t * @param   { String } name - name of the DOM node we want to create\n\t * @param   { Boolean } isSvg - true if we need to use an svg node\n\t * @returns { Object } DOM node just created\n\t */\n\tfunction mkEl(name) {\n\t  return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n\t}\n\t\n\t/**\n\t * Set the inner html of any DOM node SVGs included\n\t * @param { Object } container - DOM node where we'll inject new html\n\t * @param { String } html - html to inject\n\t */\n\t/* istanbul ignore next */\n\tfunction setInnerHTML(container, html) {\n\t  if (!isUndefined(container.innerHTML))\n\t    { container.innerHTML = html; }\n\t    // some browsers do not support innerHTML on the SVGs tags\n\t  else {\n\t    var doc = new DOMParser().parseFromString(html, 'application/xml');\n\t    var node = container.ownerDocument.importNode(doc.documentElement, true);\n\t    container.appendChild(node);\n\t  }\n\t}\n\t\n\t/**\n\t * Toggle the visibility of any DOM node\n\t * @param   { Object }  dom - DOM node we want to hide\n\t * @param   { Boolean } show - do we want to show it?\n\t */\n\t\n\tfunction toggleVisibility(dom, show) {\n\t  dom.style.display = show ? '' : 'none';\n\t  dom['hidden'] = show ? false : true;\n\t}\n\t\n\t/**\n\t * Remove any DOM attribute from a node\n\t * @param   { Object } dom - DOM node we want to update\n\t * @param   { String } name - name of the property we want to remove\n\t */\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name);\n\t}\n\t\n\t/**\n\t * Convert a style object to a string\n\t * @param   { Object } style - style object we need to parse\n\t * @returns { String } resulting css string\n\t * @example\n\t * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n\t */\n\tfunction styleObjectToString(style) {\n\t  return Object.keys(style).reduce(function (acc, prop) {\n\t    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n\t  }, '')\n\t}\n\t\n\t/**\n\t * Get the value of any DOM attribute on a node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { String } name - name of the attribute we want to get\n\t * @returns { String | undefined } name of the node attribute whether it exists\n\t */\n\tfunction getAttr(dom, name) {\n\t  return dom.getAttribute(name)\n\t}\n\t\n\t/**\n\t * Set any DOM attribute\n\t * @param { Object } dom - DOM node we want to update\n\t * @param { String } name - name of the property we want to set\n\t * @param { String } val - value of the property we want to set\n\t */\n\tfunction setAttr(dom, name, val) {\n\t  var xlink = XLINK_REGEX.exec(name);\n\t  if (xlink && xlink[1])\n\t    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n\t  else\n\t    { dom.setAttribute(name, val); }\n\t}\n\t\n\t/**\n\t * Insert safely a tag to fix #1962 #1649\n\t * @param   { HTMLElement } root - children container\n\t * @param   { HTMLElement } curr - node to insert\n\t * @param   { HTMLElement } next - node that should preceed the current node inserted\n\t */\n\tfunction safeInsert(root, curr, next) {\n\t  root.insertBefore(curr, next.parentNode && next);\n\t}\n\t\n\t/**\n\t * Minimize risk: only zero or one _space_ between attr & value\n\t * @param   { String }   html - html string we want to parse\n\t * @param   { Function } fn - callback function to apply on any attribute found\n\t */\n\tfunction walkAttrs(html, fn) {\n\t  if (!html)\n\t    { return }\n\t  var m;\n\t  while (m = RE_HTML_ATTRS.exec(html))\n\t    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n\t}\n\t\n\t/**\n\t * Walk down recursively all the children tags starting dom node\n\t * @param   { Object }   dom - starting node where we will start the recursion\n\t * @param   { Function } fn - callback to transform the child node just found\n\t * @param   { Object }   context - fn can optionally return an object, which is passed to children\n\t */\n\tfunction walkNodes(dom, fn, context) {\n\t  if (dom) {\n\t    var res = fn(dom, context);\n\t    var next;\n\t    // stop the recursion\n\t    if (res === false) { return }\n\t\n\t    dom = dom.firstChild;\n\t\n\t    while (dom) {\n\t      next = dom.nextSibling;\n\t      walkNodes(dom, fn, res);\n\t      dom = next;\n\t    }\n\t  }\n\t}\n\t\n\tvar dom = Object.freeze({\n\t\t$$: $$,\n\t\t$: $,\n\t\tcreateFrag: createFrag,\n\t\tcreateDOMPlaceholder: createDOMPlaceholder,\n\t\tisSvg: isSvg,\n\t\tmkEl: mkEl,\n\t\tsetInnerHTML: setInnerHTML,\n\t\ttoggleVisibility: toggleVisibility,\n\t\tremAttr: remAttr,\n\t\tstyleObjectToString: styleObjectToString,\n\t\tgetAttr: getAttr,\n\t\tsetAttr: setAttr,\n\t\tsafeInsert: safeInsert,\n\t\twalkAttrs: walkAttrs,\n\t\twalkNodes: walkNodes\n\t});\n\t\n\tvar styleNode;\n\tvar cssTextProp;\n\tvar byName = {};\n\tvar remainder = [];\n\tvar needsInject = false;\n\t\n\t// skip the following code on the server\n\tif (WIN) {\n\t  styleNode = (function () {\n\t    // create a new style element with the correct type\n\t    var newNode = mkEl('style');\n\t    setAttr(newNode, 'type', 'text/css');\n\t\n\t    // replace any user node or insert the new one into the head\n\t    var userNode = $('style[type=riot]');\n\t    /* istanbul ignore next */\n\t    if (userNode) {\n\t      if (userNode.id) { newNode.id = userNode.id; }\n\t      userNode.parentNode.replaceChild(newNode, userNode);\n\t    }\n\t    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\t\n\t    return newNode\n\t  })();\n\t  cssTextProp = styleNode.styleSheet;\n\t}\n\t\n\t/**\n\t * Object that will be used to inject and manage the css of every tag instance\n\t */\n\tvar styleManager = {\n\t  styleNode: styleNode,\n\t  /**\n\t   * Save a tag style to be later injected into DOM\n\t   * @param { String } css - css string\n\t   * @param { String } name - if it's passed we will map the css to a tagname\n\t   */\n\t  add: function add(css, name) {\n\t    if (name) { byName[name] = css; }\n\t    else { remainder.push(css); }\n\t    needsInject = true;\n\t  },\n\t  /**\n\t   * Inject all previously saved tag styles into DOM\n\t   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n\t   */\n\t  inject: function inject() {\n\t    if (!WIN || !needsInject) { return }\n\t    needsInject = false;\n\t    var style = Object.keys(byName)\n\t      .map(function(k) { return byName[k] })\n\t      .concat(remainder).join('\\n');\n\t    /* istanbul ignore next */\n\t    if (cssTextProp) { cssTextProp.cssText = style; }\n\t    else { styleNode.innerHTML = style; }\n\t  }\n\t};\n\t\n\t/**\n\t * The riot template engine\n\t * @version v3.0.8\n\t */\n\t\n\tvar skipRegex = (function () { //eslint-disable-line no-unused-vars\n\t\n\t  var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\t\n\t  var beforeReWords = [\n\t    'case',\n\t    'default',\n\t    'do',\n\t    'else',\n\t    'in',\n\t    'instanceof',\n\t    'prefix',\n\t    'return',\n\t    'typeof',\n\t    'void',\n\t    'yield'\n\t  ];\n\t\n\t  var wordsLastChar = beforeReWords.reduce(function (s, w) {\n\t    return s + w.slice(-1)\n\t  }, '');\n\t\n\t  var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n\t  var RE_VN_CHAR = /[$\\w]/;\n\t\n\t  function prev (code, pos) {\n\t    while (--pos >= 0 && /\\s/.test(code[pos])){  }\n\t    return pos\n\t  }\n\t\n\t  function _skipRegex (code, start) {\n\t\n\t    var re = /.*/g;\n\t    var pos = re.lastIndex = start++;\n\t    var match = re.exec(code)[0].match(RE_REGEX);\n\t\n\t    if (match) {\n\t      var next = pos + match[0].length;\n\t\n\t      pos = prev(code, pos);\n\t      var c = code[pos];\n\t\n\t      if (pos < 0 || ~beforeReChars.indexOf(c)) {\n\t        return next\n\t      }\n\t\n\t      if (c === '.') {\n\t\n\t        if (code[pos - 1] === '.') {\n\t          start = next;\n\t        }\n\t\n\t      } else if (c === '+' || c === '-') {\n\t\n\t        if (code[--pos] !== c ||\n\t            (pos = prev(code, pos)) < 0 ||\n\t            !RE_VN_CHAR.test(code[pos])) {\n\t          start = next;\n\t        }\n\t\n\t      } else if (~wordsLastChar.indexOf(c)) {\n\t\n\t        var end = pos + 1;\n\t\n\t        while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){  }\n\t        if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n\t          start = next;\n\t        }\n\t      }\n\t    }\n\t\n\t    return start\n\t  }\n\t\n\t  return _skipRegex\n\t\n\t})();\n\t\n\t/**\n\t * riot.util.brackets\n\t *\n\t * - `brackets    ` - Returns a string or regex based on its parameter\n\t * - `brackets.set` - Change the current riot brackets\n\t *\n\t * @module\n\t */\n\t\n\t/* global riot */\n\t\n\t/* istanbul ignore next */\n\tvar brackets = (function (UNDEF) {\n\t\n\t  var\n\t    REGLOB = 'g',\n\t\n\t    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\t\n\t    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\t\n\t    S_QBLOCKS = R_STRINGS.source + '|' +\n\t      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n\t      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\t\n\t    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\t\n\t    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\t\n\t    S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\t\n\t    FINDBRACES = {\n\t      '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n\t      '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n\t      '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n\t    },\n\t\n\t    DEFAULT = '{ }';\n\t\n\t  var _pairs = [\n\t    '{', '}',\n\t    '{', '}',\n\t    /{[^}]*}/,\n\t    /\\\\([{}])/g,\n\t    /\\\\({)|{/g,\n\t    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n\t    DEFAULT,\n\t    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n\t    /(^|[^\\\\]){=[\\S\\s]*?}/\n\t  ];\n\t\n\t  var\n\t    cachedBrackets = UNDEF,\n\t    _regex,\n\t    _cache = [],\n\t    _settings;\n\t\n\t  function _loopback (re) { return re }\n\t\n\t  function _rewrite (re, bp) {\n\t    if (!bp) { bp = _cache; }\n\t    return new RegExp(\n\t      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n\t    )\n\t  }\n\t\n\t  function _create (pair) {\n\t    if (pair === DEFAULT) { return _pairs }\n\t\n\t    var arr = pair.split(' ');\n\t\n\t    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n\t      throw new Error('Unsupported brackets \"' + pair + '\"')\n\t    }\n\t    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\t\n\t    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n\t    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n\t    arr[6] = _rewrite(_pairs[6], arr);\n\t    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n\t    arr[8] = pair;\n\t    return arr\n\t  }\n\t\n\t  function _brackets (reOrIdx) {\n\t    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n\t  }\n\t\n\t  _brackets.split = function split (str, tmpl, _bp) {\n\t    // istanbul ignore next: _bp is for the compiler\n\t    if (!_bp) { _bp = _cache; }\n\t\n\t    var\n\t      parts = [],\n\t      match,\n\t      isexpr,\n\t      start,\n\t      pos,\n\t      re = _bp[6];\n\t\n\t    var qblocks = [];\n\t    var prevStr = '';\n\t    var mark, lastIndex;\n\t\n\t    isexpr = start = re.lastIndex = 0;\n\t\n\t    while ((match = re.exec(str))) {\n\t\n\t      lastIndex = re.lastIndex;\n\t      pos = match.index;\n\t\n\t      if (isexpr) {\n\t\n\t        if (match[2]) {\n\t\n\t          var ch = match[2];\n\t          var rech = FINDBRACES[ch];\n\t          var ix = 1;\n\t\n\t          rech.lastIndex = lastIndex;\n\t          while ((match = rech.exec(str))) {\n\t            if (match[1]) {\n\t              if (match[1] === ch) { ++ix; }\n\t              else if (!--ix) { break }\n\t            } else {\n\t              rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n\t            }\n\t          }\n\t          re.lastIndex = ix ? str.length : rech.lastIndex;\n\t          continue\n\t        }\n\t\n\t        if (!match[3]) {\n\t          re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n\t          continue\n\t        }\n\t      }\n\t\n\t      if (!match[1]) {\n\t        unescapeStr(str.slice(start, pos));\n\t        start = re.lastIndex;\n\t        re = _bp[6 + (isexpr ^= 1)];\n\t        re.lastIndex = start;\n\t      }\n\t    }\n\t\n\t    if (str && start < str.length) {\n\t      unescapeStr(str.slice(start));\n\t    }\n\t\n\t    parts.qblocks = qblocks;\n\t\n\t    return parts\n\t\n\t    function unescapeStr (s) {\n\t      if (prevStr) {\n\t        s = prevStr + s;\n\t        prevStr = '';\n\t      }\n\t      if (tmpl || isexpr) {\n\t        parts.push(s && s.replace(_bp[5], '$1'));\n\t      } else {\n\t        parts.push(s);\n\t      }\n\t    }\n\t\n\t    function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n\t      if (slash) {\n\t        _lastIndex = skipRegex(str, _pos);\n\t      }\n\t\n\t      if (tmpl && _lastIndex > _pos + 2) {\n\t        mark = '\\u2057' + qblocks.length + '~';\n\t        qblocks.push(str.slice(_pos, _lastIndex));\n\t        prevStr += str.slice(start, _pos) + mark;\n\t        start = _lastIndex;\n\t      }\n\t      return _lastIndex\n\t    }\n\t  };\n\t\n\t  _brackets.hasExpr = function hasExpr (str) {\n\t    return _cache[4].test(str)\n\t  };\n\t\n\t  _brackets.loopKeys = function loopKeys (expr) {\n\t    var m = expr.match(_cache[9]);\n\t\n\t    return m\n\t      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n\t      : { val: expr.trim() }\n\t  };\n\t\n\t  _brackets.array = function array (pair) {\n\t    return pair ? _create(pair) : _cache\n\t  };\n\t\n\t  function _reset (pair) {\n\t    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n\t      _cache = _create(pair);\n\t      _regex = pair === DEFAULT ? _loopback : _rewrite;\n\t      _cache[9] = _regex(_pairs[9]);\n\t    }\n\t    cachedBrackets = pair;\n\t  }\n\t\n\t  function _setSettings (o) {\n\t    var b;\n\t\n\t    o = o || {};\n\t    b = o.brackets;\n\t    Object.defineProperty(o, 'brackets', {\n\t      set: _reset,\n\t      get: function () { return cachedBrackets },\n\t      enumerable: true\n\t    });\n\t    _settings = o;\n\t    _reset(b);\n\t  }\n\t\n\t  Object.defineProperty(_brackets, 'settings', {\n\t    set: _setSettings,\n\t    get: function () { return _settings }\n\t  });\n\t\n\t  /* istanbul ignore next: in the browser riot is always in the scope */\n\t  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n\t  _brackets.set = _reset;\n\t  _brackets.skipRegex = skipRegex;\n\t\n\t  _brackets.R_STRINGS = R_STRINGS;\n\t  _brackets.R_MLCOMMS = R_MLCOMMS;\n\t  _brackets.S_QBLOCKS = S_QBLOCKS;\n\t  _brackets.S_QBLOCK2 = S_QBLOCK2;\n\t\n\t  return _brackets\n\t\n\t})();\n\t\n\t/**\n\t * @module tmpl\n\t *\n\t * tmpl          - Root function, returns the template value, render with data\n\t * tmpl.hasExpr  - Test the existence of a expression inside a string\n\t * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n\t */\n\t\n\t/* istanbul ignore next */\n\tvar tmpl = (function () {\n\t\n\t  var _cache = {};\n\t\n\t  function _tmpl (str, data) {\n\t    if (!str) { return str }\n\t\n\t    return (_cache[str] || (_cache[str] = _create(str))).call(\n\t      data, _logErr.bind({\n\t        data: data,\n\t        tmpl: str\n\t      })\n\t    )\n\t  }\n\t\n\t  _tmpl.hasExpr = brackets.hasExpr;\n\t\n\t  _tmpl.loopKeys = brackets.loopKeys;\n\t\n\t  // istanbul ignore next\n\t  _tmpl.clearCache = function () { _cache = {}; };\n\t\n\t  _tmpl.errorHandler = null;\n\t\n\t  function _logErr (err, ctx) {\n\t\n\t    err.riotData = {\n\t      tagName: ctx && ctx.__ && ctx.__.tagName,\n\t      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n\t    };\n\t\n\t    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n\t    else if (\n\t      typeof console !== 'undefined' &&\n\t      typeof console.error === 'function'\n\t    ) {\n\t      console.error(err.message);\n\t      console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n\t      console.log(this.data); // eslint-disable-line\n\t    }\n\t  }\n\t\n\t  function _create (str) {\n\t    var expr = _getTmpl(str);\n\t\n\t    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\t\n\t    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n\t  }\n\t\n\t  var RE_DQUOTE = /\\u2057/g;\n\t  var RE_QBMARK = /\\u2057(\\d+)~/g;\n\t\n\t  function _getTmpl (str) {\n\t    var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\t    var qstr = parts.qblocks;\n\t    var expr;\n\t\n\t    if (parts.length > 2 || parts[0]) {\n\t      var i, j, list = [];\n\t\n\t      for (i = j = 0; i < parts.length; ++i) {\n\t\n\t        expr = parts[i];\n\t\n\t        if (expr && (expr = i & 1\n\t\n\t            ? _parseExpr(expr, 1, qstr)\n\t\n\t            : '\"' + expr\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/\\r\\n?|\\n/g, '\\\\n')\n\t                .replace(/\"/g, '\\\\\"') +\n\t              '\"'\n\t\n\t          )) { list[j++] = expr; }\n\t\n\t      }\n\t\n\t      expr = j < 2 ? list[0]\n\t           : '[' + list.join(',') + '].join(\"\")';\n\t\n\t    } else {\n\t\n\t      expr = _parseExpr(parts[1], 0, qstr);\n\t    }\n\t\n\t    if (qstr.length) {\n\t      expr = expr.replace(RE_QBMARK, function (_, pos) {\n\t        return qstr[pos]\n\t          .replace(/\\r/g, '\\\\r')\n\t          .replace(/\\n/g, '\\\\n')\n\t      });\n\t    }\n\t    return expr\n\t  }\n\t\n\t  var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n\t  var\n\t    RE_BREND = {\n\t      '(': /[()]/g,\n\t      '[': /[[\\]]/g,\n\t      '{': /[{}]/g\n\t    };\n\t\n\t  function _parseExpr (expr, asText, qstr) {\n\t\n\t    expr = expr\n\t      .replace(/\\s+/g, ' ').trim()\n\t      .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\t\n\t    if (expr) {\n\t      var\n\t        list = [],\n\t        cnt = 0,\n\t        match;\n\t\n\t      while (expr &&\n\t            (match = expr.match(RE_CSNAME)) &&\n\t            !match.index\n\t        ) {\n\t        var\n\t          key,\n\t          jsb,\n\t          re = /,|([[{(])|$/g;\n\t\n\t        expr = RegExp.rightContext;\n\t        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\t\n\t        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\t\n\t        jsb  = expr.slice(0, match.index);\n\t        expr = RegExp.rightContext;\n\t\n\t        list[cnt++] = _wrapExpr(jsb, 1, key);\n\t      }\n\t\n\t      expr = !cnt ? _wrapExpr(expr, asText)\n\t           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n\t    }\n\t    return expr\n\t\n\t    function skipBraces (ch, re) {\n\t      var\n\t        mm,\n\t        lv = 1,\n\t        ir = RE_BREND[ch];\n\t\n\t      ir.lastIndex = re.lastIndex;\n\t      while (mm = ir.exec(expr)) {\n\t        if (mm[0] === ch) { ++lv; }\n\t        else if (!--lv) { break }\n\t      }\n\t      re.lastIndex = lv ? expr.length : ir.lastIndex;\n\t    }\n\t  }\n\t\n\t  // istanbul ignore next: not both\n\t  var // eslint-disable-next-line max-len\n\t    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n\t    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n\t    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\t\n\t  function _wrapExpr (expr, asText, key) {\n\t    var tb;\n\t\n\t    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n\t      if (mvar) {\n\t        pos = tb ? 0 : pos + match.length;\n\t\n\t        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n\t          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n\t          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n\t        } else if (pos) {\n\t          tb = !JS_NOPROPS.test(s.slice(pos));\n\t        }\n\t      }\n\t      return match\n\t    });\n\t\n\t    if (tb) {\n\t      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n\t    }\n\t\n\t    if (key) {\n\t\n\t      expr = (tb\n\t          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n\t        ) + '?\"' + key + '\":\"\"';\n\t\n\t    } else if (asText) {\n\t\n\t      expr = 'function(v){' + (tb\n\t          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n\t        ) + ';return v||v===0?v:\"\"}.call(this)';\n\t    }\n\t\n\t    return expr\n\t  }\n\t\n\t  _tmpl.version = brackets.version = 'v3.0.8';\n\t\n\t  return _tmpl\n\t\n\t})();\n\t\n\t/* istanbul ignore next */\n\tvar observable$1 = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {};\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice;\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given `event` ands\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } event - event id\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(event, fn) {\n\t        if (typeof fn == 'function')\n\t          { (callbacks[event] = callbacks[event] || []).push(fn); }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given `event` listeners\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(event, fn) {\n\t        if (event == '*' && !fn) { callbacks = {}; }\n\t        else {\n\t          if (fn) {\n\t            var arr = callbacks[event];\n\t            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t              if (cb == fn) { arr.splice(i--, 1); }\n\t            }\n\t          } else { delete callbacks[event]; }\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given `event` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(event, fn) {\n\t        function on() {\n\t          el.off(event, on);\n\t          fn.apply(el, arguments);\n\t        }\n\t        return el.on(event, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given `event`\n\t     * @param   { String } event - event id\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(event) {\n\t        var arguments$1 = arguments;\n\t\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns,\n\t          fn,\n\t          i;\n\t\n\t        for (i = 0; i < arglen; i++) {\n\t          args[i] = arguments$1[i + 1]; // skip first argument\n\t        }\n\t\n\t        fns = slice.call(callbacks[event] || [], 0);\n\t\n\t        for (i = 0; fn = fns[i]; ++i) {\n\t          fn.apply(el, args);\n\t        }\n\t\n\t        if (callbacks['*'] && event != '*')\n\t          { el.trigger.apply(el, ['*', event].concat(args)); }\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  });\n\t\n\t  return el\n\t\n\t};\n\t\n\t/**\n\t * Specialized function for looping an array-like collection with `each={}`\n\t * @param   { Array } list - collection of items\n\t * @param   {Function} fn - callback function\n\t * @returns { Array } the array looped\n\t */\n\tfunction each(list, fn) {\n\t  var len = list ? list.length : 0;\n\t  var i = 0;\n\t  for (; i < len; ++i) {\n\t    fn(list[i], i);\n\t  }\n\t  return list\n\t}\n\t\n\t/**\n\t * Check whether an array contains an item\n\t * @param   { Array } array - target array\n\t * @param   { * } item - item to test\n\t * @returns { Boolean } -\n\t */\n\tfunction contains(array, item) {\n\t  return array.indexOf(item) !== -1\n\t}\n\t\n\t/**\n\t * Convert a string containing dashes to camel case\n\t * @param   { String } str - input string\n\t * @returns { String } my-string -> myString\n\t */\n\tfunction toCamel(str) {\n\t  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n\t}\n\t\n\t/**\n\t * Faster String startsWith alternative\n\t * @param   { String } str - source string\n\t * @param   { String } value - test string\n\t * @returns { Boolean } -\n\t */\n\tfunction startsWith(str, value) {\n\t  return str.slice(0, value.length) === value\n\t}\n\t\n\t/**\n\t * Helper function to set an immutable property\n\t * @param   { Object } el - object where the new property will be set\n\t * @param   { String } key - object key where the new property will be stored\n\t * @param   { * } value - value of the new property\n\t * @param   { Object } options - set the propery overriding the default options\n\t * @returns { Object } - the initial object\n\t */\n\tfunction defineProperty(el, key, value, options) {\n\t  Object.defineProperty(el, key, extend({\n\t    value: value,\n\t    enumerable: false,\n\t    writable: false,\n\t    configurable: true\n\t  }, options));\n\t  return el\n\t}\n\t\n\t/**\n\t * Extend any object with other properties\n\t * @param   { Object } src - source object\n\t * @returns { Object } the resulting extended object\n\t *\n\t * var obj = { foo: 'baz' }\n\t * extend(obj, {bar: 'bar', foo: 'bar'})\n\t * console.log(obj) => {bar: 'bar', foo: 'bar'}\n\t *\n\t */\n\tfunction extend(src) {\n\t  var obj, args = arguments;\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if (obj = args[i]) {\n\t      for (var key in obj) {\n\t        // check if this property of the source object could be overridden\n\t        if (isWritable(src, key))\n\t          { src[key] = obj[key]; }\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\tvar misc = Object.freeze({\n\t\teach: each,\n\t\tcontains: contains,\n\t\ttoCamel: toCamel,\n\t\tstartsWith: startsWith,\n\t\tdefineProperty: defineProperty,\n\t\textend: extend\n\t});\n\t\n\tvar settings$1 = extend(Object.create(brackets.settings), {\n\t  skipAnonymousTags: true,\n\t  // handle the auto updates on any DOM event\n\t  autoUpdate: true\n\t});\n\t\n\t/**\n\t * Trigger DOM events\n\t * @param   { HTMLElement } dom - dom element target of the event\n\t * @param   { Function } handler - user function\n\t * @param   { Object } e - event object\n\t */\n\tfunction handleEvent(dom, handler, e) {\n\t  var ptag = this.__.parent,\n\t    item = this.__.item;\n\t\n\t  if (!item)\n\t    { while (ptag && !item) {\n\t      item = ptag.__.item;\n\t      ptag = ptag.__.parent;\n\t    } }\n\t\n\t  // override the event properties\n\t  /* istanbul ignore next */\n\t  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n\t  /* istanbul ignore next */\n\t  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n\t  /* istanbul ignore next */\n\t  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\t\n\t  e.item = item;\n\t\n\t  handler.call(this, e);\n\t\n\t  // avoid auto updates\n\t  if (!settings$1.autoUpdate) { return }\n\t\n\t  if (!e.preventUpdate) {\n\t    var p = getImmediateCustomParentTag(this);\n\t    // fixes #2083\n\t    if (p.isMounted) { p.update(); }\n\t  }\n\t}\n\t\n\t/**\n\t * Attach an event to a DOM node\n\t * @param { String } name - event name\n\t * @param { Function } handler - event callback\n\t * @param { Object } dom - dom node\n\t * @param { Tag } tag - tag instance\n\t */\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t  var eventName,\n\t    cb = handleEvent.bind(tag, dom, handler);\n\t\n\t  // avoid to bind twice the same event\n\t  // possible fix for #2332\n\t  dom[name] = null;\n\t\n\t  // normalize event name\n\t  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\t\n\t  // cache the listener into the listeners array\n\t  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n\t  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n\t  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\t\n\t  dom[RIOT_EVENTS_KEY][name] = cb;\n\t  dom.addEventListener(eventName, cb, false);\n\t}\n\t\n\t/**\n\t * Update dynamically created data-is tags with changing expressions\n\t * @param { Object } expr - expression tag and expression info\n\t * @param { Tag }    parent - parent for tag creation\n\t * @param { String } tagName - tag implementation we want to use\n\t */\n\tfunction updateDataIs(expr, parent, tagName) {\n\t  var conf, isVirtual, head, ref;\n\t\n\t  if (expr.tag && expr.tagName === tagName) {\n\t    expr.tag.update();\n\t    return\n\t  }\n\t\n\t  isVirtual = expr.dom.tagName === 'VIRTUAL';\n\t  // sync _parent to accommodate changing tagnames\n\t  if (expr.tag) {\n\t    // need placeholder before unmount\n\t    if(isVirtual) {\n\t      head = expr.tag.__.head;\n\t      ref = createDOMPlaceholder();\n\t      head.parentNode.insertBefore(ref, head);\n\t    }\n\t\n\t    expr.tag.unmount(true);\n\t  }\n\t\n\t  if (!isString(tagName)) { return }\n\t\n\t  expr.impl = __TAG_IMPL[tagName];\n\t  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n\t  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n\t  each(expr.attrs, function (a) { return setAttr(expr.tag.root, a.name, a.value); });\n\t  expr.tagName = tagName;\n\t  expr.tag.mount();\n\t  if (isVirtual)\n\t    { makeReplaceVirtual(expr.tag, ref || expr.tag.root); } // root exist first time, after use placeholder\n\t\n\t  // parent is the placeholder tag, not the dynamic tag so clean up\n\t  parent.__.onUnmount = function() {\n\t    var delName = expr.tag.opts.dataIs,\n\t      tags = expr.tag.parent.tags,\n\t      _tags = expr.tag.__.parent.tags;\n\t    arrayishRemove(tags, delName, expr.tag);\n\t    arrayishRemove(_tags, delName, expr.tag);\n\t    expr.tag.unmount();\n\t  };\n\t}\n\t\n\t/**\n\t * Nomalize any attribute removing the \"riot-\" prefix\n\t * @param   { String } attrName - original attribute name\n\t * @returns { String } valid html attribute name\n\t */\n\tfunction normalizeAttrName(attrName) {\n\t  if (!attrName) { return null }\n\t  attrName = attrName.replace(ATTRS_PREFIX, '');\n\t  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n\t  return attrName\n\t}\n\t\n\t/**\n\t * Update on single tag expression\n\t * @this Tag\n\t * @param { Object } expr - expression logic\n\t * @returns { undefined }\n\t */\n\tfunction updateExpression(expr) {\n\t  if (this.root && getAttr(this.root,'virtualized')) { return }\n\t\n\t  var dom = expr.dom,\n\t    // remove the riot- prefix\n\t    attrName = normalizeAttrName(expr.attr),\n\t    isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n\t    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n\t    parent = dom && (expr.parent || dom.parentNode),\n\t    // detect the style attributes\n\t    isStyleAttr = attrName === 'style',\n\t    isClassAttr = attrName === 'class',\n\t    hasValue,\n\t    isObj,\n\t    value;\n\t\n\t  // if it's a tag we could totally skip the rest\n\t  if (expr._riot_id) {\n\t    if (expr.isMounted) {\n\t      expr.update();\n\t    // if it hasn't been mounted yet, do that now.\n\t    } else {\n\t      expr.mount();\n\t      if (isVirtual) {\n\t        makeReplaceVirtual(expr, expr.root);\n\t      }\n\t    }\n\t    return\n\t  }\n\t  // if this expression has the update method it means it can handle the DOM changes by itself\n\t  if (expr.update) { return expr.update() }\n\t\n\t  // ...it seems to be a simple expression so we try to calculat its value\n\t  value = tmpl(expr.expr, isToggle ? extend({}, Object.create(this.parent), this) : this);\n\t  hasValue = !isBlank(value);\n\t  isObj = isObject(value);\n\t\n\t  // convert the style/class objects to strings\n\t  if (isObj) {\n\t    isObj = !isClassAttr && !isStyleAttr;\n\t    if (isClassAttr) {\n\t      value = tmpl(JSON.stringify(value), this);\n\t    } else if (isStyleAttr) {\n\t      value = styleObjectToString(value);\n\t    }\n\t  }\n\t\n\t  // remove original attribute\n\t  if (expr.attr && (!expr.isAttrRemoved || !hasValue || value === false)) {\n\t    remAttr(dom, expr.attr);\n\t    expr.isAttrRemoved = true;\n\t  }\n\t\n\t  // for the boolean attributes we don't need the value\n\t  // we can convert it to checked=true to checked=checked\n\t  if (expr.bool) { value = value ? attrName : false; }\n\t  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n\t  if (expr.wasParsedOnce && expr.value === value) { return }\n\t\n\t  // update the expression value\n\t  expr.value = value;\n\t  expr.wasParsedOnce = true;\n\t\n\t  // if the value is an object we can not do much more with it\n\t  if (isObj && !isToggle) { return }\n\t  // avoid to render undefined/null values\n\t  if (isBlank(value)) { value = ''; }\n\t\n\t  // textarea and text nodes have no attribute name\n\t  if (!attrName) {\n\t    // about #815 w/o replace: the browser converts the value to a string,\n\t    // the comparison by \"==\" does too, but not in the server\n\t    value += '';\n\t    // test for parent avoids error with invalid assignment to nodeValue\n\t    if (parent) {\n\t      // cache the parent node because somehow it will become null on IE\n\t      // on the next iteration\n\t      expr.parent = parent;\n\t      if (parent.tagName === 'TEXTAREA') {\n\t        parent.value = value;                    // #1113\n\t        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n\t      }                                         // will be available on 'updated'\n\t      else { dom.nodeValue = value; }\n\t    }\n\t    return\n\t  }\n\t\n\t\n\t  // event handler\n\t  if (isFunction(value)) {\n\t    setEventHandler(attrName, value, dom, this);\n\t  // show / hide\n\t  } else if (isToggle) {\n\t    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n\t  // handle attributes\n\t  } else {\n\t    if (expr.bool) {\n\t      dom[attrName] = value;\n\t    }\n\t\n\t    if (attrName === 'value' && dom.value !== value) {\n\t      dom.value = value;\n\t    }\n\t\n\t    if (hasValue && value !== false) {\n\t      setAttr(dom, attrName, value);\n\t    }\n\t\n\t    // make sure that in case of style changes\n\t    // the element stays hidden\n\t    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n\t  }\n\t}\n\t\n\t/**\n\t * Update all the expressions in a Tag instance\n\t * @this Tag\n\t * @param { Array } expressions - expression that must be re evaluated\n\t */\n\tfunction updateAllExpressions(expressions) {\n\t  each(expressions, updateExpression.bind(this));\n\t}\n\t\n\tvar IfExpr = {\n\t  init: function init(dom, tag, expr) {\n\t    remAttr(dom, CONDITIONAL_DIRECTIVE);\n\t    this.tag = tag;\n\t    this.expr = expr;\n\t    this.stub = createDOMPlaceholder();\n\t    this.pristine = dom;\n\t\n\t    var p = dom.parentNode;\n\t    p.insertBefore(this.stub, dom);\n\t    p.removeChild(dom);\n\t\n\t    return this\n\t  },\n\t  update: function update() {\n\t    this.value = tmpl(this.expr, this.tag);\n\t\n\t    if (this.value && !this.current) { // insert\n\t      this.current = this.pristine.cloneNode(true);\n\t      this.stub.parentNode.insertBefore(this.current, this.stub);\n\t      this.expressions = [];\n\t      parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n\t    } else if (!this.value && this.current) { // remove\n\t      unmountAll(this.expressions);\n\t      if (this.current._tag) {\n\t        this.current._tag.unmount();\n\t      } else if (this.current.parentNode) {\n\t        this.current.parentNode.removeChild(this.current);\n\t      }\n\t      this.current = null;\n\t      this.expressions = [];\n\t    }\n\t\n\t    if (this.value) { updateAllExpressions.call(this.tag, this.expressions); }\n\t  },\n\t  unmount: function unmount() {\n\t    unmountAll(this.expressions || []);\n\t  }\n\t};\n\t\n\tvar RefExpr = {\n\t  init: function init(dom, parent, attrName, attrValue) {\n\t    this.dom = dom;\n\t    this.attr = attrName;\n\t    this.rawValue = attrValue;\n\t    this.parent = parent;\n\t    this.hasExp = tmpl.hasExpr(attrValue);\n\t    return this\n\t  },\n\t  update: function update() {\n\t    var old = this.value;\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n\t    var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\t\n\t    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\t\n\t    // the name changed, so we need to remove it from the old key (if present)\n\t    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n\t    if (!isBlank(this.value) && isString(this.value)) {\n\t      // add it to the refs of parent tag (this behavior was changed >=3.0)\n\t      if (customParent) { arrayishAdd(\n\t        customParent.refs,\n\t        this.value,\n\t        tagOrDom,\n\t        // use an array if it's a looped node and the ref is not an expression\n\t        null,\n\t        this.parent.__.index\n\t      ); }\n\t\n\t      if (this.value !== old) {\n\t        setAttr(this.dom, this.attr, this.value);\n\t      }\n\t    } else {\n\t      remAttr(this.dom, this.attr);\n\t    }\n\t\n\t    // cache the ref bound to this dom node\n\t    // to reuse it in future (see also #2329)\n\t    if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n\t  },\n\t  unmount: function unmount() {\n\t    var tagOrDom = this.tag || this.dom;\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t    if (!isBlank(this.value) && customParent)\n\t      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\t  }\n\t};\n\t\n\t/**\n\t * Convert the item looped into an object used to extend the child tag properties\n\t * @param   { Object } expr - object containing the keys used to extend the children tags\n\t * @param   { * } key - value to assign to the new object returned\n\t * @param   { * } val - value containing the position of the item in the array\n\t * @param   { Object } base - prototype object for the new item\n\t * @returns { Object } - new object containing the values of the original item\n\t *\n\t * The variables 'key' and 'val' are arbitrary.\n\t * They depend on the collection type looped (Array, Object)\n\t * and on the expression used on the each tag\n\t *\n\t */\n\tfunction mkitem(expr, key, val, base) {\n\t  var item = base ? Object.create(base) : {};\n\t  item[expr.key] = key;\n\t  if (expr.pos) { item[expr.pos] = val; }\n\t  return item\n\t}\n\t\n\t/**\n\t * Unmount the redundant tags\n\t * @param   { Array } items - array containing the current items to loop\n\t * @param   { Array } tags - array containing all the children tags\n\t */\n\tfunction unmountRedundant(items, tags) {\n\t  var i = tags.length,\n\t    j = items.length;\n\t\n\t  while (i > j) {\n\t    i--;\n\t    remove.apply(tags[i], [tags, i]);\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Remove a child tag\n\t * @this Tag\n\t * @param   { Array } tags - tags collection\n\t * @param   { Number } i - index of the tag to remove\n\t */\n\tfunction remove(tags, i) {\n\t  tags.splice(i, 1);\n\t  this.unmount();\n\t  arrayishRemove(this.parent, this, this.__.tagName, true);\n\t}\n\t\n\t/**\n\t * Move the nested custom tags in non custom loop tags\n\t * @this Tag\n\t * @param   { Number } i - current position of the loop tag\n\t */\n\tfunction moveNestedTags(i) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(this.tags), function (tagName) {\n\t    moveChildTag.apply(this$1.tags[tagName], [tagName, i]);\n\t  });\n\t}\n\t\n\t/**\n\t * Move a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction move(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { moveVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Insert and mount a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction insert(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Append a new tag into the DOM\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction append(root, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.call(this, root); }\n\t  else\n\t    { root.appendChild(this.root); }\n\t}\n\t\n\t/**\n\t * Manage tags having the 'each'\n\t * @param   { HTMLElement } dom - DOM node we need to loop\n\t * @param   { Tag } parent - parent tag instance where the dom node is contained\n\t * @param   { String } expr - string contained in the 'each' attribute\n\t * @returns { Object } expression object for this each loop\n\t */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  // remove the each property from the original tag\n\t  remAttr(dom, LOOP_DIRECTIVE);\n\t\n\t  var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE),\n\t    tagName = getTagName(dom),\n\t    impl = __TAG_IMPL[tagName],\n\t    parentNode = dom.parentNode,\n\t    placeholder = createDOMPlaceholder(),\n\t    child = getTag(dom),\n\t    ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE),\n\t    tags = [],\n\t    oldItems = [],\n\t    hasKeys,\n\t    isLoop = true,\n\t    isAnonymous = !__TAG_IMPL[tagName],\n\t    isVirtual = dom.tagName === 'VIRTUAL';\n\t\n\t  // parse the each expression\n\t  expr = tmpl.loopKeys(expr);\n\t  expr.isLoop = true;\n\t\n\t  if (ifExpr) { remAttr(dom, CONDITIONAL_DIRECTIVE); }\n\t\n\t  // insert a marked where the loop tags will be injected\n\t  parentNode.insertBefore(placeholder, dom);\n\t  parentNode.removeChild(dom);\n\t\n\t  expr.update = function updateEach() {\n\t    // get the new items collection\n\t    expr.value = tmpl(expr.val, parent);\n\t\n\t    var frag = createFrag(),\n\t      items = expr.value,\n\t      isObject$$1 = !isArray(items) && !isString(items),\n\t      root = placeholder.parentNode;\n\t\n\t    // if this DOM was removed the update here is useless\n\t    // this condition fixes also a weird async issue on IE in our unit test\n\t    if (!root) { return }\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (isObject$$1) {\n\t      hasKeys = items || false;\n\t      items = hasKeys ?\n\t        Object.keys(items).map(function (key) {\n\t          return mkitem(expr, items[key], key)\n\t        }) : [];\n\t    } else {\n\t      hasKeys = false;\n\t    }\n\t\n\t    if (ifExpr) {\n\t      items = items.filter(function(item, i) {\n\t        if (expr.key && !isObject$$1)\n\t          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\t\n\t        return !!tmpl(ifExpr, extend(Object.create(parent), item))\n\t      });\n\t    }\n\t\n\t    // loop all the new items\n\t    each(items, function(item, i) {\n\t      // reorder only if the items are objects\n\t      var\n\t        doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n\t        oldPos = oldItems.indexOf(item),\n\t        isNew = oldPos === -1,\n\t        pos = !isNew && doReorder ? oldPos : i,\n\t        // does a tag exist in this position?\n\t        tag = tags[pos],\n\t        mustAppend = i >= oldItems.length,\n\t        mustCreate =  doReorder && isNew || !doReorder && !tag;\n\t\n\t      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\t\n\t      // new tag\n\t      if (mustCreate) {\n\t        tag = new Tag$1(impl, {\n\t          parent: parent,\n\t          isLoop: isLoop,\n\t          isAnonymous: isAnonymous,\n\t          tagName: tagName,\n\t          root: dom.cloneNode(isAnonymous),\n\t          item: item,\n\t          index: i,\n\t        }, dom.innerHTML);\n\t\n\t        // mount the tag\n\t        tag.mount();\n\t\n\t        if (mustAppend)\n\t          { append.apply(tag, [frag || root, isVirtual]); }\n\t        else\n\t          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\t\n\t        if (!mustAppend) { oldItems.splice(i, 0, item); }\n\t        tags.splice(i, 0, tag);\n\t        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n\t      } else if (pos !== i && doReorder) {\n\t        // move\n\t        if (contains(items, oldItems[pos])) {\n\t          move.apply(tag, [root, tags[i], isVirtual]);\n\t          // move the old tag instance\n\t          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n\t          // move the old item\n\t          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n\t        }\n\t\n\t        // update the position attribute if it exists\n\t        if (expr.pos) { tag[expr.pos] = i; }\n\t\n\t        // if the loop tags are not custom\n\t        // we need to move all their custom tags into the right position\n\t        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n\t      }\n\t\n\t      // cache the original item to use it in the events bound to this node\n\t      // and its children\n\t      tag.__.item = item;\n\t      tag.__.index = i;\n\t      tag.__.parent = parent;\n\t\n\t      if (!mustCreate) { tag.update(item); }\n\t    });\n\t\n\t    // remove the redundant tags\n\t    unmountRedundant(items, tags);\n\t\n\t    // clone the items array\n\t    oldItems = items.slice();\n\t\n\t    // this condition is weird u\n\t    root.insertBefore(frag, placeholder);\n\t  };\n\t\n\t  expr.unmount = function() {\n\t    each(tags, function(t) { t.unmount(); });\n\t  };\n\t\n\t  return expr\n\t}\n\t\n\t/**\n\t * Walk the tag DOM to detect the expressions to evaluate\n\t * @this Tag\n\t * @param   { HTMLElement } root - root tag where we will start digging the expressions\n\t * @param   { Array } expressions - empty array where the expressions will be added\n\t * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n\t * @returns { Object } an object containing the root noode and the dom tree\n\t */\n\tfunction parseExpressions(root, expressions, mustIncludeRoot) {\n\t  var this$1 = this;\n\t\n\t  var tree = {parent: {children: expressions}};\n\t\n\t  walkNodes(root, function (dom, ctx) {\n\t    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n\t    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\t\n\t    // text node\n\t    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n\t      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\t\n\t    if (type !== 1) { return ctx } // not an element\n\t\n\t    var isVirtual = dom.tagName === 'VIRTUAL';\n\t\n\t    // loop. each does it's own thing (for now)\n\t    if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n\t      if(isVirtual) { setAttr(dom, 'loopVirtual', true); } // ignore here, handled in _each\n\t      parent.children.push(_each(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    // if-attrs become the new parent. Any following expressions (either on the current\n\t    // element, or below it) become children of this expression.\n\t    if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n\t      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    if (expr = getAttr(dom, IS_DIRECTIVE)) {\n\t      if (tmpl.hasExpr(expr)) {\n\t        parent.children.push({isRtag: true, expr: expr, dom: dom, attrs: [].slice.call(dom.attributes)});\n\t        return false\n\t      }\n\t    }\n\t\n\t    // if this is a tag, stop traversing here.\n\t    // we ignore the root, since parseExpressions is called while we're mounting that root\n\t    tagImpl = getTag(dom);\n\t    if(isVirtual) {\n\t      if(getAttr(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n\t      if(!tagImpl && !getAttr(dom, 'virtualized') && !getAttr(dom, 'loopVirtual'))  // ok to create virtual tag\n\t        { tagImpl = { tmpl: dom.outerHTML }; }\n\t    }\n\t\n\t    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n\t      if(isVirtual && !getAttr(dom, IS_DIRECTIVE)) { // handled in update\n\t        // can not remove attribute like directives\n\t        // so flag for removal after creation to prevent maximum stack error\n\t        setAttr(dom, 'virtualized', true);\n\t\n\t        var tag = new Tag$1({ tmpl: dom.outerHTML },\n\t          {root: dom, parent: this$1},\n\t          dom.innerHTML);\n\t        parent.children.push(tag); // no return, anonymous tag, keep parsing\n\t      } else {\n\t        var conf = {root: dom, parent: this$1, hasImpl: true};\n\t        parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n\t        return false\n\t      }\n\t    }\n\t\n\t    // attribute expressions\n\t    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n\t      if (!expr) { return }\n\t      parent.children.push(expr);\n\t    }]);\n\t\n\t    // whatever the parent is, all child elements get the same parent.\n\t    // If this element had an if-attr, that's the parent for all child elements\n\t    return {parent: parent}\n\t  }, tree);\n\t}\n\t\n\t/**\n\t * Calls `fn` for every attribute on an element. If that attr has an expression,\n\t * it is also passed to fn.\n\t * @this Tag\n\t * @param   { HTMLElement } dom - dom node to parse\n\t * @param   { Array } attrs - array of attributes\n\t * @param   { Function } fn - callback to exec on any iteration\n\t */\n\tfunction parseAttributes(dom, attrs, fn) {\n\t  var this$1 = this;\n\t\n\t  each(attrs, function (attr) {\n\t    if (!attr) { return false }\n\t\n\t    var name = attr.name, bool = isBoolAttr(name), expr;\n\t\n\t    if (contains(REF_DIRECTIVES, name)) {\n\t      expr =  Object.create(RefExpr).init(dom, this$1, name, attr.value);\n\t    } else if (tmpl.hasExpr(attr.value)) {\n\t      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n\t    }\n\t\n\t    fn(attr, expr);\n\t  });\n\t}\n\t\n\t/*\n\t  Includes hacks needed for the Internet Explorer version 9 and below\n\t  See: http://kangax.github.io/compat-table/es5/#ie8\n\t       http://codeplanet.io/dropping-ie8/\n\t*/\n\t\n\tvar reHasYield  = /<yield\\b/i;\n\tvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\n\tvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\n\tvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\n\tvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\n\tvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\n\tvar GENERIC = 'div';\n\tvar SVG = 'svg';\n\t\n\t\n\t/*\n\t  Creates the root element for table or select child elements:\n\t  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n\t*/\n\tfunction specialTags(el, tmpl, tagName) {\n\t\n\t  var\n\t    select = tagName[0] === 'o',\n\t    parent = select ? 'select>' : 'table>';\n\t\n\t  // trim() is important here, this ensures we don't have artifacts,\n\t  // so we can check if we have only one element inside the parent\n\t  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n\t  parent = el.firstChild;\n\t\n\t  // returns the immediate parent if tr/th/td/col is the only element, if not\n\t  // returns the whole tree, as this can include additional elements\n\t  /* istanbul ignore next */\n\t  if (select) {\n\t    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n\t  } else {\n\t    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n\t    var tname = rootEls[tagName];\n\t    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n\t  }\n\t  return parent\n\t}\n\t\n\t/*\n\t  Replace the yield tag from any tag template with the innerHTML of the\n\t  original tag in the page\n\t*/\n\tfunction replaceYield(tmpl, html) {\n\t  // do nothing if no yield\n\t  if (!reHasYield.test(tmpl)) { return tmpl }\n\t\n\t  // be careful with #1343 - string on the source having `$1`\n\t  var src = {};\n\t\n\t  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n\t    src[ref] = src[ref] || text;   // preserve first definition\n\t    return ''\n\t  }).trim();\n\t\n\t  return tmpl\n\t    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n\t      return src[ref] || def || ''\n\t    })\n\t    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n\t      return html || def || ''\n\t    })\n\t}\n\t\n\t/**\n\t * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n\t * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n\t *\n\t * @param   { String } tmpl  - The template coming from the custom tag definition\n\t * @param   { String } html - HTML content that comes from the DOM element where you\n\t *           will mount the tag, mostly the original tag in the page\n\t * @param   { Boolean } isSvg - true if the root node is an svg\n\t * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n\t */\n\tfunction mkdom(tmpl, html, isSvg$$1) {\n\t  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n\t    tagName = match && match[1].toLowerCase(),\n\t    el = mkEl(isSvg$$1 ? SVG : GENERIC);\n\t\n\t  // replace all the yield tags with the tag inner html\n\t  tmpl = replaceYield(tmpl, html);\n\t\n\t  /* istanbul ignore next */\n\t  if (tblTags.test(tagName))\n\t    { el = specialTags(el, tmpl, tagName); }\n\t  else\n\t    { setInnerHTML(el, tmpl); }\n\t\n\t  return el\n\t}\n\t\n\t/**\n\t * Another way to create a riot tag a bit more es6 friendly\n\t * @param { HTMLElement } el - tag DOM selector or DOM node/s\n\t * @param { Object } opts - tag logic\n\t * @returns { Tag } new riot tag instance\n\t */\n\tfunction Tag$2(el, opts) {\n\t  // get the tag properties from the class constructor\n\t  var ref = this;\n\t  var name = ref.name;\n\t  var tmpl = ref.tmpl;\n\t  var css = ref.css;\n\t  var attrs = ref.attrs;\n\t  var onCreate = ref.onCreate;\n\t  // register a new tag and cache the class prototype\n\t  if (!__TAG_IMPL[name]) {\n\t    tag$1(name, tmpl, css, attrs, onCreate);\n\t    // cache the class constructor\n\t    __TAG_IMPL[name].class = this.constructor;\n\t  }\n\t\n\t  // mount the tag using the class instance\n\t  mountTo(el, name, opts, this);\n\t  // inject the component css\n\t  if (css) { styleManager.inject(); }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag$1(name, tmpl, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs;\n\t\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css;\n\t      css = '';\n\t    } else\n\t      { attrs = ''; }\n\t  }\n\t\n\t  if (css) {\n\t    if (isFunction(css))\n\t      { fn = css; }\n\t    else\n\t      { styleManager.add(css); }\n\t  }\n\t\n\t  name = name.toLowerCase();\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation (for use by the compiler)\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag2$1(name, tmpl, css, attrs, fn) {\n\t  if (css) { styleManager.add(css, name); }\n\t\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Mount a tag using a specific tag implementation\n\t * @param   { * } selector - tag DOM selector or DOM node/s\n\t * @param   { String } tagName - tag implementation name\n\t * @param   { Object } opts - tag logic\n\t * @returns { Array } new tags instances\n\t */\n\tfunction mount$1(selector, tagName, opts) {\n\t  var tags = [];\n\t  var elem, allTags;\n\t\n\t  function pushTagsTo(root) {\n\t    if (root.tagName) {\n\t      var riotTag = getAttr(root, IS_DIRECTIVE), tag;\n\t\n\t      // have tagName? force riot-tag to be the same\n\t      if (tagName && riotTag !== tagName) {\n\t        riotTag = tagName;\n\t        setAttr(root, IS_DIRECTIVE, tagName);\n\t      }\n\t\n\t      tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\t\n\t      if (tag)\n\t        { tags.push(tag); }\n\t    } else if (root.length)\n\t      { each(root, pushTagsTo); } // assume nodeList\n\t  }\n\t\n\t  // inject styles into DOM\n\t  styleManager.inject();\n\t\n\t  if (isObject(tagName)) {\n\t    opts = tagName;\n\t    tagName = 0;\n\t  }\n\t\n\t  // crawl the DOM to find the tag\n\t  if (isString(selector)) {\n\t    selector = selector === '*' ?\n\t      // select all registered tags\n\t      // & tags found with the riot-tag attribute set\n\t      allTags = selectTags() :\n\t      // or just the ones named like the selector\n\t      selector + selectTags(selector.split(/, */));\n\t\n\t    // make sure to pass always a selector\n\t    // to the querySelectorAll function\n\t    elem = selector ? $$(selector) : [];\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    { elem = selector; }\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectTags();\n\t    // if the root els it's just a single tag\n\t    if (elem.tagName)\n\t      { elem = $$(tagName, elem); }\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = [];\n\t\n\t      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\t\n\t      elem = nodeList;\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0;\n\t  }\n\t\n\t  pushTagsTo(elem);\n\t\n\t  return tags\n\t}\n\t\n\t// Create a mixin that could be globally shared across all the tags\n\tvar mixins = {};\n\tvar globals = mixins[GLOBAL_MIXIN] = {};\n\tvar mixins_id = 0;\n\t\n\t/**\n\t * Create/Return a mixin by its name\n\t * @param   { String }  name - mixin name (global mixin if object)\n\t * @param   { Object }  mix - mixin logic\n\t * @param   { Boolean } g - is global?\n\t * @returns { Object }  the mixin logic\n\t */\n\tfunction mixin$1(name, mix, g) {\n\t  // Unnamed global\n\t  if (isObject(name)) {\n\t    mixin$1((\"__\" + (mixins_id++) + \"__\"), name, true);\n\t    return\n\t  }\n\t\n\t  var store = g ? globals : mixins;\n\t\n\t  // Getter\n\t  if (!mix) {\n\t    if (isUndefined(store[name]))\n\t      { throw new Error((\"Unregistered mixin: \" + name)) }\n\t\n\t    return store[name]\n\t  }\n\t\n\t  // Setter\n\t  store[name] = isFunction(mix) ?\n\t    extend(mix.prototype, store[name] || {}) && mix :\n\t    extend(store[name] || {}, mix);\n\t}\n\t\n\t/**\n\t * Update all the tags instances created\n\t * @returns { Array } all the tags instances\n\t */\n\tfunction update$1() {\n\t  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n\t}\n\t\n\tfunction unregister$1(name) {\n\t  __TAG_IMPL[name] = null;\n\t}\n\t\n\tvar version$1 = 'v3.6.1';\n\t\n\t\n\tvar core = Object.freeze({\n\t\tTag: Tag$2,\n\t\ttag: tag$1,\n\t\ttag2: tag2$1,\n\t\tmount: mount$1,\n\t\tmixin: mixin$1,\n\t\tupdate: update$1,\n\t\tunregister: unregister$1,\n\t\tversion: version$1\n\t});\n\t\n\t// counter to give a unique id to all the Tag instances\n\tvar __uid = 0;\n\t\n\t/**\n\t * We need to update opts for this tag. That requires updating the expressions\n\t * in any attributes on the tag, and then copying the result onto opts.\n\t * @this Tag\n\t * @param   {Boolean} isLoop - is it a loop tag?\n\t * @param   { Tag }  parent - parent tag node\n\t * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n\t * @param   { Object }  opts - tag options\n\t * @param   { Array }  instAttrs - tag attributes array\n\t */\n\tfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n\t  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n\t  // (and only this case) we don't need to do updateOpts, because the regular parse\n\t  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n\t  if (isLoop && isAnonymous) { return }\n\t\n\t  var ctx = !isAnonymous && isLoop ? this : parent || this;\n\t  each(instAttrs, function (attr) {\n\t    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n\t    // normalize the attribute names\n\t    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n\t  });\n\t}\n\t\n\t\n\t/**\n\t * Tag class\n\t * @constructor\n\t * @param { Object } impl - it contains the tag template, and logic\n\t * @param { Object } conf - tag options\n\t * @param { String } innerHTML - html that eventually we need to inject in the tag\n\t */\n\tfunction Tag$1(impl, conf, innerHTML) {\n\t  if ( impl === void 0 ) impl = {};\n\t  if ( conf === void 0 ) conf = {};\n\t\n\t  var opts = extend({}, conf.opts),\n\t    parent = conf.parent,\n\t    isLoop = conf.isLoop,\n\t    isAnonymous = !!conf.isAnonymous,\n\t    skipAnonymous = settings$1.skipAnonymousTags && isAnonymous,\n\t    item = cleanUpData(conf.item),\n\t    index = conf.index, // available only for the looped nodes\n\t    instAttrs = [], // All attributes on the Tag when it's first parsed\n\t    implAttrs = [], // expressions on this type of Tag\n\t    expressions = [],\n\t    root = conf.root,\n\t    tagName = conf.tagName || getTagName(root),\n\t    isVirtual = tagName === 'virtual',\n\t    isInline = !isVirtual && !impl.tmpl,\n\t    propsInSyncWithParent = [],\n\t    dom;\n\t\n\t  // make this tag observable\n\t  if (!skipAnonymous) { observable$1(this); }\n\t  // only call unmount if we have a valid __TAG_IMPL (has name property)\n\t  if (impl.name && root._tag) { root._tag.unmount(true); }\n\t\n\t  // not yet mounted\n\t  this.isMounted = false;\n\t\n\t  defineProperty(this, '__', {\n\t    isAnonymous: isAnonymous,\n\t    instAttrs: instAttrs,\n\t    innerHTML: innerHTML,\n\t    tagName: tagName,\n\t    index: index,\n\t    isLoop: isLoop,\n\t    isInline: isInline,\n\t    // tags having event listeners\n\t    // it would be better to use weak maps here but we can not introduce breaking changes now\n\t    listeners: [],\n\t    // these vars will be needed only for the virtual tags\n\t    virts: [],\n\t    tail: null,\n\t    head: null,\n\t    parent: null,\n\t    item: null\n\t  });\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n\t  defineProperty(this, 'root', root);\n\t  extend(this, { opts: opts }, item);\n\t  // protect the \"tags\" and \"refs\" property from being overridden\n\t  defineProperty(this, 'parent', parent || null);\n\t  defineProperty(this, 'tags', {});\n\t  defineProperty(this, 'refs', {});\n\t\n\t  if (isInline || isLoop && isAnonymous) {\n\t    dom = root;\n\t  } else {\n\t    if (!isVirtual) { root.innerHTML = ''; }\n\t    dom = mkdom(impl.tmpl, innerHTML, isSvg(root));\n\t  }\n\t\n\t  /**\n\t   * Update the tag expressions and options\n\t   * @param   { * }  data - data we want to use to extend the tag properties\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'update', function tagUpdate(data) {\n\t    var nextOpts = {},\n\t      canTrigger = this.isMounted && !skipAnonymous;\n\t\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data);\n\t    extend(this, data);\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, nextOpts, instAttrs]);\n\t\n\t    if (canTrigger && this.isMounted && isFunction(this.shouldUpdate) && !this.shouldUpdate(data, nextOpts)) {\n\t      return this\n\t    }\n\t\n\t    // inherit properties from the parent, but only for isAnonymous tags\n\t    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n\t    extend(opts, nextOpts);\n\t    if (canTrigger) { this.trigger('update', data); }\n\t    updateAllExpressions.call(this, expressions);\n\t    if (canTrigger) { this.trigger('updated'); }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Add a mixin to this tag\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mixin', function tagMixin() {\n\t    var this$1 = this;\n\t\n\t    each(arguments, function (mix) {\n\t      var instance, obj;\n\t      var props = [];\n\t\n\t      // properties blacklisted and will not be bound to the tag instance\n\t      var propsBlacklist = ['init', '__proto__'];\n\t\n\t      mix = isString(mix) ? mixin$1(mix) : mix;\n\t\n\t      // check if the mixin is a function\n\t      if (isFunction(mix)) {\n\t        // create the new mixin instance\n\t        instance = new mix();\n\t      } else { instance = mix; }\n\t\n\t      var proto = Object.getPrototypeOf(instance);\n\t\n\t      // build multilevel prototype inheritance chain property list\n\t      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n\t      while (obj = Object.getPrototypeOf(obj || instance))\n\t\n\t      // loop the keys in the function prototype or the all object keys\n\t      each(props, function (key) {\n\t        // bind methods to this\n\t        // allow mixins to override other properties/parent mixins\n\t        if (!contains(propsBlacklist, key)) {\n\t          // check for getters/setters\n\t          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n\t          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\t\n\t          // apply method only if it does not already exist on the instance\n\t          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n\t            Object.defineProperty(this$1, key, descriptor);\n\t          } else {\n\t            this$1[key] = isFunction(instance[key]) ?\n\t              instance[key].bind(this$1) :\n\t              instance[key];\n\t          }\n\t        }\n\t      });\n\t\n\t      // init method will be called automatically\n\t      if (instance.init)\n\t        { instance.init.bind(this$1)(); }\n\t    });\n\t    return this\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Mount the current tag instance\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mount', function tagMount() {\n\t    var this$1 = this;\n\t\n\t    root._tag = this; // keep a reference to the tag just created\n\t\n\t    // Read all the attrs on this instance. This give us the info we need for updateOpts\n\t    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n\t      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n\t      attr.expr = expr;\n\t      instAttrs.push(attr);\n\t    }]);\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    implAttrs = [];\n\t    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n\t    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n\t      if (expr) { expressions.push(expr); }\n\t      else { setAttr(root, attr.name, attr.value); }\n\t    }]);\n\t\n\t    // initialiation\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\t\n\t    // add global mixins\n\t    var globalMixin = mixin$1(GLOBAL_MIXIN);\n\t\n\t    if (globalMixin && !skipAnonymous) {\n\t      for (var i in globalMixin) {\n\t        if (globalMixin.hasOwnProperty(i)) {\n\t          this$1.mixin(globalMixin[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (impl.fn) { impl.fn.call(this, opts); }\n\t\n\t    if (!skipAnonymous) { this.trigger('before-mount'); }\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions.apply(this, [dom, expressions, isAnonymous]);\n\t\n\t    this.update(item);\n\t\n\t    if (!isAnonymous && !isInline) {\n\t      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n\t    }\n\t\n\t    defineProperty(this, 'root', root);\n\t    defineProperty(this, 'isMounted', true);\n\t\n\t    if (skipAnonymous) { return }\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!this.parent) {\n\t      this.trigger('mount');\n\t    }\n\t    // otherwise we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n\t    else {\n\t      var p = getImmediateCustomParentTag(this.parent);\n\t      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n\t        this$1.trigger('mount');\n\t      });\n\t    }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Unmount the tag instance\n\t   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n\t    var this$1 = this;\n\t\n\t    var el = this.root,\n\t      p = el.parentNode,\n\t      ptag,\n\t      tagIndex = __TAGS_CACHE.indexOf(this);\n\t\n\t    if (!skipAnonymous) { this.trigger('before-unmount'); }\n\t\n\t    // clear all attributes coming from the mounted tag\n\t    walkAttrs(impl.attrs, function (name) {\n\t      if (startsWith(name, ATTRS_PREFIX))\n\t        { name = name.slice(ATTRS_PREFIX.length); }\n\t\n\t      remAttr(root, name);\n\t    });\n\t\n\t    // remove all the event listeners\n\t    this.__.listeners.forEach(function (dom) {\n\t      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n\t        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n\t      });\n\t    });\n\t\n\t    // remove this tag instance from the global virtualDom variable\n\t    if (tagIndex !== -1)\n\t      { __TAGS_CACHE.splice(tagIndex, 1); }\n\t\n\t    if (p || isVirtual) {\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent);\n\t\n\t        if (isVirtual) {\n\t          Object.keys(this.tags).forEach(function (tagName) {\n\t            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n\t          });\n\t        } else {\n\t          arrayishRemove(ptag.tags, tagName, this);\n\t          // remove from _parent too\n\t          if(parent !== ptag) {\n\t            arrayishRemove(parent.tags, tagName, this);\n\t          }\n\t        }\n\t      } else {\n\t        // remove the tag contents\n\t        setInnerHTML(el, '');\n\t      }\n\t\n\t      if (p && !mustKeepRoot) { p.removeChild(el); }\n\t    }\n\t\n\t    if (this.__.virts) {\n\t      each(this.__.virts, function (v) {\n\t        if (v.parentNode) { v.parentNode.removeChild(v); }\n\t      });\n\t    }\n\t\n\t    // allow expressions to unmount themselves\n\t    unmountAll(expressions);\n\t    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\t\n\t    // custom internal unmount function to avoid relying on the observable\n\t    if (this.__.onUnmount) { this.__.onUnmount(); }\n\t\n\t    if (!skipAnonymous) {\n\t      this.trigger('unmount');\n\t      this.off('*');\n\t    }\n\t\n\t    defineProperty(this, 'isMounted', false);\n\t\n\t    delete this.root._tag;\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t}\n\t\n\t/**\n\t * Detect the tag implementation by a DOM node\n\t * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n\t * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n\t */\n\tfunction getTag(dom) {\n\t  return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) ||\n\t    getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n\t}\n\t\n\t/**\n\t * Inherit properties from a target tag instance\n\t * @this Tag\n\t * @param   { Tag } target - tag where we will inherit properties\n\t * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n\t */\n\tfunction inheritFrom(target, propsInSyncWithParent) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(target), function (k) {\n\t    // some properties must be always in sync with the parent tag\n\t    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\t\n\t    if (isUndefined(this$1[k]) || mustSync) {\n\t      // track the property to keep in sync\n\t      // so we can keep it updated\n\t      if (!mustSync) { propsInSyncWithParent.push(k); }\n\t      this$1[k] = target[k];\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Move the position of a custom tag in its parent tag\n\t * @this Tag\n\t * @param   { String } tagName - key where the tag was stored\n\t * @param   { Number } newPos - index where the new tag will be stored\n\t */\n\tfunction moveChildTag(tagName, newPos) {\n\t  var parent = this.parent,\n\t    tags;\n\t  // no parent no move\n\t  if (!parent) { return }\n\t\n\t  tags = parent.tags[tagName];\n\t\n\t  if (isArray(tags))\n\t    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n\t  else { arrayishAdd(parent.tags, tagName, this); }\n\t}\n\t\n\t/**\n\t * Create a new child tag including it correctly into its parent\n\t * @param   { Object } child - child tag implementation\n\t * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n\t * @param   { String } innerHTML - inner html of the child node\n\t * @param   { Object } parent - instance of the parent tag including the child custom tag\n\t * @returns { Object } instance of the new child tag just created\n\t */\n\tfunction initChildTag(child, opts, innerHTML, parent) {\n\t  var tag = new Tag$1(child, opts, innerHTML),\n\t    tagName = opts.tagName || getTagName(opts.root, true),\n\t    ptag = getImmediateCustomParentTag(parent);\n\t  // fix for the parent attribute in the looped elements\n\t  defineProperty(tag, 'parent', ptag);\n\t  // store the real parent tag\n\t  // in some cases this could be different from the custom parent tag\n\t  // for example in nested loops\n\t  tag.__.parent = parent;\n\t\n\t  // add this tag to the custom parent tag\n\t  arrayishAdd(ptag.tags, tagName, tag);\n\t\n\t  // and also to the real parent tag\n\t  if (ptag !== parent)\n\t    { arrayishAdd(parent.tags, tagName, tag); }\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * Loop backward all the parents tree to detect the first custom parent tag\n\t * @param   { Object } tag - a Tag instance\n\t * @returns { Object } the instance of the first custom parent tag found\n\t */\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag;\n\t  while (ptag.__.isAnonymous) {\n\t    if (!ptag.parent) { break }\n\t    ptag = ptag.parent;\n\t  }\n\t  return ptag\n\t}\n\t\n\t/**\n\t * Trigger the unmount method on all the expressions\n\t * @param   { Array } expressions - DOM expressions\n\t */\n\tfunction unmountAll(expressions) {\n\t  each(expressions, function(expr) {\n\t    if (expr instanceof Tag$1) { expr.unmount(true); }\n\t    else if (expr.tagName) { expr.tag.unmount(true); }\n\t    else if (expr.unmount) { expr.unmount(); }\n\t  });\n\t}\n\t\n\t/**\n\t * Get the tag name of any DOM node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n\t * @returns { String } name to identify this dom node in riot\n\t */\n\tfunction getTagName(dom, skipDataIs) {\n\t  var child = getTag(dom),\n\t    namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n\t  return namedTag && !tmpl.hasExpr(namedTag) ?\n\t                namedTag :\n\t              child ? child.name : dom.tagName.toLowerCase()\n\t}\n\t\n\t/**\n\t * With this function we avoid that the internal Tag methods get overridden\n\t * @param   { Object } data - options we want to use to extend the tag instance\n\t * @returns { Object } clean object without containing the riot internal reserved words\n\t */\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag$1) && !(data && isFunction(data.trigger)))\n\t    { return data }\n\t\n\t  var o = {};\n\t  for (var key in data) {\n\t    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n\t  }\n\t  return o\n\t}\n\t\n\t/**\n\t * Set the property of an object for a given key. If something already\n\t * exists there, then it becomes an array containing both the old and new value.\n\t * @param { Object } obj - object on which to set the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be set\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t * @param { Number } index - add the new item in a certain array position\n\t */\n\tfunction arrayishAdd(obj, key, value, ensureArray, index) {\n\t  var dest = obj[key];\n\t  var isArr = isArray(dest);\n\t  var hasIndex = !isUndefined(index);\n\t\n\t  if (dest && dest === value) { return }\n\t\n\t  // if the key was never set, set it once\n\t  if (!dest && ensureArray) { obj[key] = [value]; }\n\t  else if (!dest) { obj[key] = value; }\n\t  // if it was an array and not yet set\n\t  else {\n\t    if (isArr) {\n\t      var oldIndex = dest.indexOf(value);\n\t      // this item never changed its position\n\t      if (oldIndex === index) { return }\n\t      // remove the item from its old position\n\t      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n\t      // move or add the item\n\t      if (hasIndex) {\n\t        dest.splice(index, 0, value);\n\t      } else {\n\t        dest.push(value);\n\t      }\n\t    } else { obj[key] = [dest, value]; }\n\t  }\n\t}\n\t\n\t/**\n\t * Removes an item from an object at a given key. If the key points to an array,\n\t * then the item is just removed from the array.\n\t * @param { Object } obj - object on which to remove the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be removed\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t*/\n\tfunction arrayishRemove(obj, key, value, ensureArray) {\n\t  if (isArray(obj[key])) {\n\t    var index = obj[key].indexOf(value);\n\t    if (index !== -1) { obj[key].splice(index, 1); }\n\t    if (!obj[key].length) { delete obj[key]; }\n\t    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n\t  } else\n\t    { delete obj[key]; } // otherwise just delete the key\n\t}\n\t\n\t/**\n\t * Mount a tag creating new Tag instance\n\t * @param   { Object } root - dom node where the tag will be mounted\n\t * @param   { String } tagName - name of the riot tag we want to mount\n\t * @param   { Object } opts - options to pass to the Tag instance\n\t * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n\t * @returns { Tag } a new Tag instance\n\t */\n\tfunction mountTo(root, tagName, opts, ctx) {\n\t  var impl = __TAG_IMPL[tagName],\n\t    implClass = __TAG_IMPL[tagName].class,\n\t    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n\t    // cache the inner HTML to fix #855\n\t    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\t\n\t  var conf = extend({ root: root, opts: opts }, { parent: opts ? opts.parent : null });\n\t\n\t  if (impl && root) { Tag$1.apply(tag, [impl, conf, innerHTML]); }\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount(true);\n\t    // add this tag to the virtualDom variable\n\t    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n\t  }\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * makes a tag virtual and replaces a reference in the dom\n\t * @this Tag\n\t * @param { tag } the tag to make virtual\n\t * @param { ref } the dom reference location\n\t */\n\tfunction makeReplaceVirtual(tag, ref) {\n\t  var frag = createFrag();\n\t  makeVirtual.call(tag, frag);\n\t  ref.parentNode.replaceChild(frag, ref);\n\t}\n\t\n\t/**\n\t * Adds the elements for a virtual tag\n\t * @this Tag\n\t * @param { Node } src - the node that will do the inserting or appending\n\t * @param { Tag } target - only if inserting, insert before this tag's first child\n\t */\n\tfunction makeVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var head = createDOMPlaceholder(),\n\t    tail = createDOMPlaceholder(),\n\t    frag = createFrag(),\n\t    sib, el;\n\t\n\t  this.root.insertBefore(head, this.root.firstChild);\n\t  this.root.appendChild(tail);\n\t\n\t  this.__.head = el = head;\n\t  this.__.tail = tail;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    this$1.__.virts.push(el); // hold for unmounting\n\t    el = sib;\n\t  }\n\t\n\t  if (target)\n\t    { src.insertBefore(frag, target.__.head); }\n\t  else\n\t    { src.appendChild(frag); }\n\t}\n\t\n\t/**\n\t * Move virtual tag and all child nodes\n\t * @this Tag\n\t * @param { Node } src  - the node that will do the inserting\n\t * @param { Tag } target - insert before this tag's first child\n\t */\n\tfunction moveVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var el = this.__.head,\n\t    frag = createFrag(),\n\t    sib;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    el = sib;\n\t    if (el === this$1.__.tail) {\n\t      frag.appendChild(el);\n\t      src.insertBefore(frag, target.__.head);\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Get selectors for tags\n\t * @param   { Array } tags - tag names to select\n\t * @returns { String } selector\n\t */\n\tfunction selectTags(tags) {\n\t  // select all tags\n\t  if (!tags) {\n\t    var keys = Object.keys(__TAG_IMPL);\n\t    return keys + selectTags(keys)\n\t  }\n\t\n\t  return tags\n\t    .filter(function (t) { return !/[^-\\w]/.test(t); })\n\t    .reduce(function (list, t) {\n\t      var name = t.trim().toLowerCase();\n\t      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n\t    }, '')\n\t}\n\t\n\t\n\tvar tags = Object.freeze({\n\t\tgetTag: getTag,\n\t\tinheritFrom: inheritFrom,\n\t\tmoveChildTag: moveChildTag,\n\t\tinitChildTag: initChildTag,\n\t\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\t\tunmountAll: unmountAll,\n\t\tgetTagName: getTagName,\n\t\tcleanUpData: cleanUpData,\n\t\tarrayishAdd: arrayishAdd,\n\t\tarrayishRemove: arrayishRemove,\n\t\tmountTo: mountTo,\n\t\tmakeReplaceVirtual: makeReplaceVirtual,\n\t\tmakeVirtual: makeVirtual,\n\t\tmoveVirtual: moveVirtual,\n\t\tselectTags: selectTags\n\t});\n\t\n\t/**\n\t * Riot public api\n\t */\n\tvar settings = settings$1;\n\tvar util = {\n\t  tmpl: tmpl,\n\t  brackets: brackets,\n\t  styleManager: styleManager,\n\t  vdom: __TAGS_CACHE,\n\t  styleNode: styleManager.styleNode,\n\t  // export the riot internal utils as well\n\t  dom: dom,\n\t  check: check,\n\t  misc: misc,\n\t  tags: tags\n\t};\n\t\n\t// export the core props/methods\n\tvar Tag$$1 = Tag$2;\n\tvar tag$$1 = tag$1;\n\tvar tag2$$1 = tag2$1;\n\tvar mount$$1 = mount$1;\n\tvar mixin$$1 = mixin$1;\n\tvar update$$1 = update$1;\n\tvar unregister$$1 = unregister$1;\n\tvar version$$1 = version$1;\n\tvar observable = observable$1;\n\t\n\tvar riot$1 = extend({}, core, {\n\t  observable: observable$1,\n\t  settings: settings,\n\t  util: util,\n\t});\n\t\n\texports.settings = settings;\n\texports.util = util;\n\texports.Tag = Tag$$1;\n\texports.tag = tag$$1;\n\texports.tag2 = tag2$$1;\n\texports.mount = mount$$1;\n\texports.mixin = mixin$$1;\n\texports.update = update$$1;\n\texports.unregister = unregister$$1;\n\texports.version = version$$1;\n\texports.observable = observable;\n\texports['default'] = riot$1;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar topIndustries = __webpack_require__(14);\n\tvar smamuIndustries = __webpack_require__(13);\n\tvar smamuGroups = __webpack_require__(17);\n\tvar industryStories = __webpack_require__(16);\n\t\n\tmodule.exports = {\n\t  topIndustries: topIndustries,\n\t  smamuIndustries: smamuIndustries,\n\t  smamuGroups: smamuGroups,\n\t  industryStories: industryStories\n\t};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('stacked-barh', '<div class=\"{getClass(\\'bar-outer\\', opts.modifier)}\"> <div each=\"{opts.data}\" class=\"{getClass(\\'bar\\', modifier)}\" riot-style=\"width:{value}%;\"> <span class=\"{getClass(\\'bar__label\\', modifier)}\">{label}</span> </div> </div>', '', 'class=\"{getClass()}\"', function (opts) {});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\t__webpack_require__(3);\n\t\n\triot.tag2('stacked-barhs', '<div class=\"{getClass(\\'legend\\')}\"> <div each=\"{label, i in opts.legend}\" class=\"{getClass(\\'legend__item\\', parent.opts.modifiers[i])}\"><span></span>{label} </div> </div> <div each=\"{data in opts.data}\" class=\"{getClass(\\'container\\')}\"> <span class=\"{getClass(\\'label\\')}\">{data[parent.opts.barlabels]}</span> <span class=\"{getClass(\\'sub-label\\')}\">Besch√§ftigte insgesamt: {_f(+data.gb_t + +data.svb_t)}</span> <stacked-barh data=\"{parent.getData(data)}\" css=\"stacked-barh\"></stacked-barh> </div> <div class=\"{getClass(\\'legend\\')}\"> <div each=\"{label, i in opts.legend}\" class=\"{getClass(\\'legend__item\\', parent.opts.modifiers[i])}\"><span></span>{label} </div> </div>', '', 'class=\"{getClass()}\"', function (opts) {\n\t  var _this = this;\n\t\n\t  this.getData = function (data) {\n\t    return _this.opts.cols.map(function (c, i) {\n\t      var value = data[c];\n\t      return {\n\t        value: value,\n\t        label: _this.opts.labelformat(value),\n\t        modifier: _this.opts.modifiers[i]\n\t      };\n\t    });\n\t  };\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar _data = __webpack_require__(2);\n\t\n\t__webpack_require__(4);\n\t\n\triot.tag2('cor-mj-industries-main', '<stacked-barhs ref=\"stacked-barhs\" data=\"{data}\" barlabels=\"name\" labelformat=\"{labelformat}\" cols=\"{[\\'gb_t_rel\\', \\'svb_t_rel\\']}\" modifiers=\"{[\\'gb\\', \\'svb\\']}\" legend=\"{[\\'Minijobs\\', \\'sozialversicherungspflichtig\\']}\"></stacked-barhs> <section class=\"{getClass(\\'annotation\\')}\"> Die angegebenen Prozentwerte beziehen sich jeweils auf die Summe der Menschen, die in Minijobs und sozialversicherungspflichtigen Besch√§ftigungen arbeiten. </section>', '', 'class=\"{getClass(\\'viz-section\\')}\"', function (opts) {\n\t  var _this = this;\n\t\n\t  this.data = _data.topIndustries.sort(function (a, b) {\n\t    return b.gb_t_rel - a.gb_t_rel;\n\t  });\n\t  this.labelformat = function (v) {\n\t    return _this._f(v) + ' %';\n\t  };\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar _data = __webpack_require__(2);\n\t\n\t__webpack_require__(7);\n\t\n\triot.tag2('cor-mj-industries-multi-charts', '<industry-chart each=\"{data in data}\" data=\"{data}\" css=\"industry-chart\"></industry-chart>', '', 'class=\"{getClass(\\'viz-section\\')}\"', function (opts) {\n\t\n\t  this.data = _data.smamuIndustries;\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar _data = __webpack_require__(2);\n\t\n\t__webpack_require__(3);\n\t\n\triot.tag2('industry-chart', '<h3 class=\"{getClass(\\'title\\')}\">{opts.data.name}</h3> <p class=\"{getClass(\\'description\\')}\">{getDesc(opts.data.name)}</p> <div class=\"{getClass(\\'charts-wrapper\\')}\"> <div each=\"{group in groups}\" class=\"{getClass(\\'chart\\')}\"> <h4 class=\"{getClass(\\'chart__label\\')}\">{group.title}</h4> <div class=\"{getClass(\\'chart__bars-container\\')}\"> <div each=\"{suffix, i in [\\'gb\\', \\'svb\\']}\" class=\"{getClass(\\'chart__stacked-barh\\', suffix)}\"> <span if=\"{!i}\" class=\"{getClass(\\'chart__stacked-barh__label\\')}\"> {labels[i]}: <strong>{getValue(group, suffix )}&nbsp;%</strong> </span> <stacked-barh data=\"{parent.parent.getData(group, suffix)}\" modifier=\"{group.field}\" css=\"stacked-barh\"></stacked-barh> <span if=\"{i}\" class=\"{getClass(\\'chart__stacked-barh__label\\')}\"> {labels[i]}: <strong>{getValue(group, suffix )}&nbsp;%</strong> </span> </div> </div> </div> </div>', '', 'class=\"{getClass()}\"', function (opts) {\n\t  var _this = this;\n\t\n\t  this.groups = _data.smamuGroups;\n\t  this.labels = ['Minijobs', 'SV-Besch√§ftigungen'];\n\t  this.getDesc = function (name) {\n\t    return _data.industryStories[name];\n\t  };\n\t  this.getValue = function (_ref, suffix) {\n\t    var field = _ref.field;\n\t    return +_this.opts.data[suffix + '_' + field];\n\t  };\n\t  this.getData = function (_ref2, suffix) {\n\t    var field = _ref2.field;\n\t\n\t    var value = _this.getValue({ field: field }, suffix);\n\t    return [value, 100 - value].map(function (val, i) {\n\t      return {\n\t        value: val,\n\t        // label: this._f(val) + ' %',\n\t        modifier: ['full', 'empty'][i]\n\t      };\n\t    });\n\t  };\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\t__webpack_require__(15);\n\t\n\tvar _class_name = __webpack_require__(10);\n\t\n\tvar _class_name2 = _interopRequireDefault(_class_name);\n\t\n\tvar _number_format = __webpack_require__(11);\n\t\n\tvar _number_format2 = _interopRequireDefault(_number_format);\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(6);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tif (false) {\n\t  module.hot.accept();\n\t}\n\t\n\t// import 'babel-polyfill'\n\t\n\t\n\t// mixins\n\t\n\triot.mixin((0, _class_name2.default)('mjid'));\n\triot.mixin(_number_format2.default);\n\t\n\t// mount vizes\n\t\n\t\n\tvar mount = function mount(name) {\n\t  var selector = '[data-riot-mount=\"' + name + '\"]';\n\t  riot.mount(selector, name);\n\t};\n\t\n\tmount('cor-mj-industries-main');\n\tmount('cor-mj-industries-multi-charts');\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _d3Format = __webpack_require__(12);\n\t\n\tObject.defineProperty(exports, 'format', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _d3Format.format;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'formatLocale', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _d3Format.formatLocale;\n\t  }\n\t});\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t// riot mixin for computing class names\n\t//\n\t// it takes a global `cssNamespace` on init that becomes prefix for all classes.\n\t//\n\t// components can have the `ref`-attribute set to append this (say, the name for this component) to the\n\t// global prefix\n\t//\n\t// components then have `this.getClass` that computes the acutal class name for something, e.g:\n\t//    global namespace is 'foo', components ref-attr is 'bar', then\n\t//      `getClass('title')` results in a class named 'foo-bar__title'\n\t//     if ref is undefined, `getClass('title')` becomes 'foo-title'\n\t\n\texports.default = function (cssNamespace) {\n\t  return {\n\t    getClass: function getClass(name) {\n\t      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var ref = this.opts.ref || this.opts.css;\n\t      var part = ref ? cssNamespace + \"-\" + ref : false;\n\t      var cssClass = name ? part ? part + \"__\" + name : cssNamespace + \"-\" + name : part;\n\t      return mod ? cssClass + \" \" + cssClass + \"--\" + mod : cssClass;\n\t    }\n\t  };\n\t};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _d = __webpack_require__(9);\n\t\n\tvar d3 = _interopRequireWildcard(_d);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar loc = d3.formatLocale({\n\t  thousands: '.',\n\t  decimal: ',',\n\t  grouping: [3]\n\t}); // riot mixin for formatting numbers to german locale\n\t\n\t\n\tvar format = loc.format(',');\n\t\n\tmodule.exports = { _f: function _f(val) {\n\t    return val && format(val);\n\t  } };\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-format/ Version 1.2.0. Copyright 2017 Mike Bostock.\n\t(function (global, factory) {\n\t\t true ? factory(exports) :\n\t\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t\t(factory((global.d3 = global.d3 || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\t// Computes the decimal coefficient and exponent of the specified number x with\n\t// significant digits p, where x is positive and p is in [1, 21] or undefined.\n\t// For example, formatDecimal(1.23) returns [\"123\", 0].\n\tvar formatDecimal = function(x, p) {\n\t  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ¬±Infinity\n\t  var i, coefficient = x.slice(0, i);\n\t\n\t  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n\t  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n\t  return [\n\t    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n\t    +x.slice(i + 1)\n\t  ];\n\t};\n\t\n\tvar exponent = function(x) {\n\t  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n\t};\n\t\n\tvar formatGroup = function(grouping, thousands) {\n\t  return function(value, width) {\n\t    var i = value.length,\n\t        t = [],\n\t        j = 0,\n\t        g = grouping[0],\n\t        length = 0;\n\t\n\t    while (i > 0 && g > 0) {\n\t      if (length + g + 1 > width) g = Math.max(1, width - length);\n\t      t.push(value.substring(i -= g, i + g));\n\t      if ((length += g + 1) > width) break;\n\t      g = grouping[j = (j + 1) % grouping.length];\n\t    }\n\t\n\t    return t.reverse().join(thousands);\n\t  };\n\t};\n\t\n\tvar formatNumerals = function(numerals) {\n\t  return function(value) {\n\t    return value.replace(/[0-9]/g, function(i) {\n\t      return numerals[+i];\n\t    });\n\t  };\n\t};\n\t\n\tvar formatDefault = function(x, p) {\n\t  x = x.toPrecision(p);\n\t\n\t  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n\t    switch (x[i]) {\n\t      case \".\": i0 = i1 = i; break;\n\t      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n\t      case \"e\": break out;\n\t      default: if (i0 > 0) i0 = 0; break;\n\t    }\n\t  }\n\t\n\t  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n\t};\n\t\n\tvar prefixExponent;\n\t\n\tvar formatPrefixAuto = function(x, p) {\n\t  var d = formatDecimal(x, p);\n\t  if (!d) return x + \"\";\n\t  var coefficient = d[0],\n\t      exponent = d[1],\n\t      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n\t      n = coefficient.length;\n\t  return i === n ? coefficient\n\t      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n\t      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n\t      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n\t};\n\t\n\tvar formatRounded = function(x, p) {\n\t  var d = formatDecimal(x, p);\n\t  if (!d) return x + \"\";\n\t  var coefficient = d[0],\n\t      exponent = d[1];\n\t  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n\t      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n\t      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n\t};\n\t\n\tvar formatTypes = {\n\t  \"\": formatDefault,\n\t  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n\t  \"b\": function(x) { return Math.round(x).toString(2); },\n\t  \"c\": function(x) { return x + \"\"; },\n\t  \"d\": function(x) { return Math.round(x).toString(10); },\n\t  \"e\": function(x, p) { return x.toExponential(p); },\n\t  \"f\": function(x, p) { return x.toFixed(p); },\n\t  \"g\": function(x, p) { return x.toPrecision(p); },\n\t  \"o\": function(x) { return Math.round(x).toString(8); },\n\t  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n\t  \"r\": formatRounded,\n\t  \"s\": formatPrefixAuto,\n\t  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n\t  \"x\": function(x) { return Math.round(x).toString(16); }\n\t};\n\t\n\t// [[fill]align][sign][symbol][0][width][,][.precision][type]\n\tvar re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\t\n\tfunction formatSpecifier(specifier) {\n\t  return new FormatSpecifier(specifier);\n\t}\n\t\n\tformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\t\n\tfunction FormatSpecifier(specifier) {\n\t  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\t\n\t  var match,\n\t      fill = match[1] || \" \",\n\t      align = match[2] || \">\",\n\t      sign = match[3] || \"-\",\n\t      symbol = match[4] || \"\",\n\t      zero = !!match[5],\n\t      width = match[6] && +match[6],\n\t      comma = !!match[7],\n\t      precision = match[8] && +match[8].slice(1),\n\t      type = match[9] || \"\";\n\t\n\t  // The \"n\" type is an alias for \",g\".\n\t  if (type === \"n\") comma = true, type = \"g\";\n\t\n\t  // Map invalid types to the default format.\n\t  else if (!formatTypes[type]) type = \"\";\n\t\n\t  // If zero fill is specified, padding goes after sign and before digits.\n\t  if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\t\n\t  this.fill = fill;\n\t  this.align = align;\n\t  this.sign = sign;\n\t  this.symbol = symbol;\n\t  this.zero = zero;\n\t  this.width = width;\n\t  this.comma = comma;\n\t  this.precision = precision;\n\t  this.type = type;\n\t}\n\t\n\tFormatSpecifier.prototype.toString = function() {\n\t  return this.fill\n\t      + this.align\n\t      + this.sign\n\t      + this.symbol\n\t      + (this.zero ? \"0\" : \"\")\n\t      + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n\t      + (this.comma ? \",\" : \"\")\n\t      + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n\t      + this.type;\n\t};\n\t\n\tvar identity = function(x) {\n\t  return x;\n\t};\n\t\n\tvar prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"¬µ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\t\n\tvar formatLocale = function(locale) {\n\t  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n\t      currency = locale.currency,\n\t      decimal = locale.decimal,\n\t      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,\n\t      percent = locale.percent || \"%\";\n\t\n\t  function newFormat(specifier) {\n\t    specifier = formatSpecifier(specifier);\n\t\n\t    var fill = specifier.fill,\n\t        align = specifier.align,\n\t        sign = specifier.sign,\n\t        symbol = specifier.symbol,\n\t        zero = specifier.zero,\n\t        width = specifier.width,\n\t        comma = specifier.comma,\n\t        precision = specifier.precision,\n\t        type = specifier.type;\n\t\n\t    // Compute the prefix and suffix.\n\t    // For SI-prefix, the suffix is lazily computed.\n\t    var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n\t        suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? percent : \"\";\n\t\n\t    // What format function should we use?\n\t    // Is this an integer type?\n\t    // Can this type generate exponential notation?\n\t    var formatType = formatTypes[type],\n\t        maybeSuffix = !type || /[defgprs%]/.test(type);\n\t\n\t    // Set the default precision if not specified,\n\t    // or clamp the specified precision to the supported range.\n\t    // For significant precision, it must be in [1, 21].\n\t    // For fixed precision, it must be in [0, 20].\n\t    precision = precision == null ? (type ? 6 : 12)\n\t        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n\t        : Math.max(0, Math.min(20, precision));\n\t\n\t    function format(value) {\n\t      var valuePrefix = prefix,\n\t          valueSuffix = suffix,\n\t          i, n, c;\n\t\n\t      if (type === \"c\") {\n\t        valueSuffix = formatType(value) + valueSuffix;\n\t        value = \"\";\n\t      } else {\n\t        value = +value;\n\t\n\t        // Perform the initial formatting.\n\t        var valueNegative = value < 0;\n\t        value = formatType(Math.abs(value), precision);\n\t\n\t        // If a negative value rounds to zero during formatting, treat as positive.\n\t        if (valueNegative && +value === 0) valueNegative = false;\n\t\n\t        // Compute the prefix and suffix.\n\t        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n\t        valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\t\n\t        // Break the formatted value into the integer ‚Äúvalue‚Äù part that can be\n\t        // grouped, and fractional or exponential ‚Äúsuffix‚Äù part that is not.\n\t        if (maybeSuffix) {\n\t          i = -1, n = value.length;\n\t          while (++i < n) {\n\t            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n\t              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n\t              value = value.slice(0, i);\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      // If the fill character is not \"0\", grouping is applied before padding.\n\t      if (comma && !zero) value = group(value, Infinity);\n\t\n\t      // Compute the padding.\n\t      var length = valuePrefix.length + value.length + valueSuffix.length,\n\t          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\t\n\t      // If the fill character is \"0\", grouping is applied after padding.\n\t      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\t\n\t      // Reconstruct the final output based on the desired alignment.\n\t      switch (align) {\n\t        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n\t        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n\t        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n\t        default: value = padding + valuePrefix + value + valueSuffix; break;\n\t      }\n\t\n\t      return numerals(value);\n\t    }\n\t\n\t    format.toString = function() {\n\t      return specifier + \"\";\n\t    };\n\t\n\t    return format;\n\t  }\n\t\n\t  function formatPrefix(specifier, value) {\n\t    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n\t        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n\t        k = Math.pow(10, -e),\n\t        prefix = prefixes[8 + e / 3];\n\t    return function(value) {\n\t      return f(k * value) + prefix;\n\t    };\n\t  }\n\t\n\t  return {\n\t    format: newFormat,\n\t    formatPrefix: formatPrefix\n\t  };\n\t};\n\t\n\tvar locale;\n\t\n\t\n\t\n\tdefaultLocale({\n\t  decimal: \".\",\n\t  thousands: \",\",\n\t  grouping: [3],\n\t  currency: [\"$\", \"\"]\n\t});\n\t\n\tfunction defaultLocale(definition) {\n\t  locale = formatLocale(definition);\n\t  exports.format = locale.format;\n\t  exports.formatPrefix = locale.formatPrefix;\n\t  return locale;\n\t}\n\t\n\tvar precisionFixed = function(step) {\n\t  return Math.max(0, -exponent(Math.abs(step)));\n\t};\n\t\n\tvar precisionPrefix = function(step, value) {\n\t  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n\t};\n\t\n\tvar precisionRound = function(step, max) {\n\t  step = Math.abs(step), max = Math.abs(max) - step;\n\t  return Math.max(0, exponent(max) - exponent(step)) + 1;\n\t};\n\t\n\texports.formatDefaultLocale = defaultLocale;\n\texports.formatLocale = formatLocale;\n\texports.formatSpecifier = formatSpecifier;\n\texports.precisionFixed = precisionFixed;\n\texports.precisionPrefix = precisionPrefix;\n\texports.precisionRound = precisionRound;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\tvar res = [{\"name\":\"Einzelhandel (ohne KFZ)\",\"svb_f\":\"70.4\",\"gb_f\":\"71.5\",\"svb_foreign\":\"8.1\",\"gb_foreign\":\"8.3\",\"svb_assistant\":\"8.8\",\"gb_assistant\":\"44.3\",\"svb_education\":\"26.3\",\"gb_education\":\"47.7\"},{\"name\":\"Gastronomie\",\"svb_f\":\"52.3\",\"gb_f\":\"62.4\",\"svb_foreign\":\"33.2\",\"gb_foreign\":\"18.0\",\"svb_assistant\":\"34.5\",\"gb_assistant\":\"44.5\",\"svb_education\":\"51.7\",\"gb_education\":\"54.8\"},{\"name\":\"Geb√§udebetreuung, Garten- und Landschaftsbau\",\"svb_f\":\"53.4\",\"gb_f\":\"63.3\",\"svb_foreign\":\"27.9\",\"gb_foreign\":\"31.9\",\"svb_assistant\":\"54.5\",\"gb_assistant\":\"75.4\",\"svb_education\":\"54.5\",\"gb_education\":\"60.7\"},{\"name\":\"Gesundheitswesen\",\"svb_f\":\"81.0\",\"gb_f\":\"78.4\",\"svb_foreign\":\"5.7\",\"gb_foreign\":\"7.2\",\"svb_assistant\":\"7.2\",\"gb_assistant\":\"37.6\",\"svb_education\":\"13.0\",\"gb_education\":\"30.0\"},{\"name\":\"Private Haushalte mit Hauspersonal\",\"svb_f\":\"86.8\",\"gb_f\":\"89.5\",\"svb_foreign\":\"27.3\",\"gb_foreign\":\"15.5\",\"svb_assistant\":\"59.9\",\"gb_assistant\":\"39.9\",\"svb_education\":\"42.6\",\"gb_education\":\"66.4\"},{\"name\":\"Baustellenarbeiten, Bauinstallation etc.\",\"svb_f\":\"14.2\",\"gb_f\":\"42.7\",\"svb_foreign\":\"11.6\",\"gb_foreign\":\"9.2\",\"svb_assistant\":\"13.5\",\"gb_assistant\":\"49.1\",\"svb_education\":\"26.7\",\"gb_education\":\"31.7\"}];res.columns = [\"name\",\"svb_f\",\"gb_f\",\"svb_foreign\",\"gb_foreign\",\"svb_assistant\",\"gb_assistant\",\"svb_education\",\"gb_education\"];module.exports = res;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\tvar res = [{\"name\":\"Einzelhandel (ohne KFZ)\",\"svb_t_relv\":\"7.5\",\"gb_t_relv\":\"12.1\",\"svb_t_rel\":\"71.9\",\"gb_t_rel\":\"28.1\",\"svb_t\":\"2351156\",\"gb_t\":\"918810\"},{\"name\":\"Gastronomie\",\"svb_t_relv\":\"2.2\",\"gb_t_relv\":\"10.2\",\"svb_t_rel\":\"47.2\",\"gb_t_rel\":\"52.8\",\"svb_t\":\"689904\",\"gb_t\":\"772007\"},{\"name\":\"Geb√§udebetreuung, Garten- und Landschaftsbau\",\"svb_t_relv\":\"2.2\",\"gb_t_relv\":\"7.8\",\"svb_t_rel\":\"54.3\",\"gb_t_rel\":\"45.7\",\"svb_t\":\"699630\",\"gb_t\":\"589605\"},{\"name\":\"Gesundheitswesen\",\"svb_t_relv\":\"7.5\",\"gb_t_relv\":\"5.7\",\"svb_t_rel\":\"84.4\",\"gb_t_rel\":\"15.6\",\"svb_t\":\"2350181\",\"gb_t\":\"432831\"},{\"name\":\"Private Haushalte mit Hauspersonal\",\"svb_t_relv\":\"0.1\",\"gb_t_relv\":\"3.7\",\"svb_t_rel\":\"14.4\",\"gb_t_rel\":\"85.6\",\"svb_t\":\"46541\",\"gb_t\":\"276737\"},{\"name\":\"Baustellenarbeiten, Bauinstallation etc.\",\"svb_t_relv\":\"3.9\",\"gb_t_relv\":\"3.3\",\"svb_t_rel\":\"83.0\",\"gb_t_rel\":\"17.0\",\"svb_t\":\"1224092\",\"gb_t\":\"250757\"}];res.columns = [\"name\",\"svb_t_relv\",\"gb_t_relv\",\"svb_t_rel\",\"gb_t_rel\",\"svb_t\",\"gb_t\"];module.exports = res;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"Einzelhandel (ohne KFZ)\": \"Im Einzelhandel arbeiten mit √ºber 900.000 die meisten Minijobber im Vergleich mit anderen Branchen. Rund f√ºnf mal so viele Minijobs im Einzelhandel haben das niedrigste Anforderungsniveau (Helfer) als in regul√§ren Jobs. Auch der Anteil der Minijobber, die keine oder eine unbekannte Berufsbildung haben, ist hier fast doppelt so hoch.\",\n\t\t\"Gastronomie\": \"Die Gastronomie ist eine klassische Minijobber-Branche, rund die H√§lfte aller Arbeitenden hier sind geringf√ºgig besch√§ftigt. Interessant: In sozialversicherungspflichtigen Anstellungen arbeiten hier mit gut 33 Prozent knapp doppelt so viele Menschen ohne deutsche Staatsb√ºrgerschaft wie in Minijobs.\",\n\t\t\"Geb√§udebetreuung, Garten- und Landschaftsbau\": \"Hierzu geh√∂ren vor allem Hausmeister- und Reinigungsdienste. In keiner anderen der gro√üen Branchen arbeiten so viele Menschen ohne Berufsabschluss und in der niedrigsten Anforderungsstufe (als Helfer), sowohl in Minijobs als auch sozialversicherungspflichtigen Besch√§ftigungen.\",\n\t\t\"Gesundheitswesen\": \"Die meisten der gut 430.000 Minijobber im Gesundheitswesen arbeiten als Helfer in Arztpraxen. Das erkl√§rt den hohen Anteil des Helfer-Anforderungsniveaus: Verglichen mit regul√§ren Anstellungsverh√§ltnissen ist hier der Anteil rund f√ºnf mal h√∂her.\",\n\t\t\"Private Haushalte mit Hauspersonal\": \"In keiner anderen Branche arbeiten anteilsm√§√üig so viele Frauen: Fast neun von zehn Minijobber sind hier weiblich. Jedoch arbeiten in sozialversicherungspflichtigen Verh√§ltnissen anderthalb mal so viele \\\"Helfer\\\" als in geringf√ºgigen.\",\n\t\t\"Baustellenarbeiten, Bauinstallation etc.\": \"Die meisten der 250.000 Minijobber arbeiten hier in der Elektroinstallation, D√§mmung und Klempnerarbeiten. In keiner anderen der hier vorgestellten Branchen ist der Frauenanteil so gering ‚Äì jedoch ausgerechnet bei den Minijobbern deutlich h√∂her als in regul√§ren Besch√§ftigungsverh√§ltnissen.\"\n\t};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = [\n\t\t{\n\t\t\t\"title\": \"Frauenanteil\",\n\t\t\t\"field\": \"f\"\n\t\t},\n\t\t{\n\t\t\t\"title\": \"Ausl√§nderanteil\",\n\t\t\t\"field\": \"foreign\"\n\t\t},\n\t\t{\n\t\t\t\"title\": \"Anforderungsniveau: Anteil Helfer\",\n\t\t\t\"field\": \"assistant\"\n\t\t},\n\t\t{\n\t\t\t\"title\": \"Keine oder unbekannte Berufsbildung\",\n\t\t\t\"field\": \"education\"\n\t\t}\n\t];\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap eea905c8843398bbafa7","/* Riot v3.6.1, @license MIT */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.riot = global.riot || {})));\n}(this, (function (exports) { 'use strict';\n\nvar __TAGS_CACHE = [];\nvar __TAG_IMPL = {};\nvar GLOBAL_MIXIN = '__global_mixin';\nvar ATTRS_PREFIX = 'riot-';\nvar REF_DIRECTIVES = ['ref', 'data-ref'];\nvar IS_DIRECTIVE = 'data-is';\nvar CONDITIONAL_DIRECTIVE = 'if';\nvar LOOP_DIRECTIVE = 'each';\nvar LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\nvar SHOW_DIRECTIVE = 'show';\nvar HIDE_DIRECTIVE = 'hide';\nvar RIOT_EVENTS_KEY = '__riot-events__';\nvar T_STRING = 'string';\nvar T_OBJECT = 'object';\nvar T_UNDEF  = 'undefined';\nvar T_FUNCTION = 'function';\nvar XLINK_NS = 'http://www.w3.org/1999/xlink';\nvar SVG_NS = 'http://www.w3.org/2000/svg';\nvar XLINK_REGEX = /^xlink:(\\w+)/;\nvar WIN = typeof window === T_UNDEF ? undefined : window;\nvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\nvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\nvar RE_EVENTS_PREFIX = /^on/;\nvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\nvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\nvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\nvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\nvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n/**\n * Check Check if the passed argument is undefined\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isUndefined(value) || value === null || value === ''\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } -\n */\nfunction isWritable(obj, key) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n/**\n * Check if passed argument is a reserved name\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isReservedName(value) {\n  return RE_RESERVED_NAMES.test(value)\n}\n\nvar check = Object.freeze({\n\tisBoolAttr: isBoolAttr,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisUndefined: isUndefined,\n\tisString: isString,\n\tisBlank: isBlank,\n\tisArray: isArray,\n\tisWritable: isWritable,\n\tisReservedName: isReservedName\n});\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return Array.prototype.slice.call((ctx || document).querySelectorAll(selector))\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFrag() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Check if a DOM node is an svg tag\n * @param   { HTMLElement }  el - node we want to test\n * @returns {Boolean} true if it's an svg node\n */\nfunction isSvg(el) {\n  return !!el.ownerSVGElement\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @param   { Boolean } isSvg - true if we need to use an svg node\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n */\n/* istanbul ignore next */\nfunction setInnerHTML(container, html) {\n  if (!isUndefined(container.innerHTML))\n    { container.innerHTML = html; }\n    // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml');\n    var node = container.ownerDocument.importNode(doc.documentElement, true);\n    container.appendChild(node);\n  }\n}\n\n/**\n * Toggle the visibility of any DOM node\n * @param   { Object }  dom - DOM node we want to hide\n * @param   { Boolean } show - do we want to show it?\n */\n\nfunction toggleVisibility(dom, show) {\n  dom.style.display = show ? '' : 'none';\n  dom['hidden'] = show ? false : true;\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Convert a style object to a string\n * @param   { Object } style - style object we need to parse\n * @returns { String } resulting css string\n * @example\n * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n */\nfunction styleObjectToString(style) {\n  return Object.keys(style).reduce(function (acc, prop) {\n    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n  }, '')\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttrs(html, fn) {\n  if (!html)\n    { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateFrag: createFrag,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tisSvg: isSvg,\n\tmkEl: mkEl,\n\tsetInnerHTML: setInnerHTML,\n\ttoggleVisibility: toggleVisibility,\n\tremAttr: remAttr,\n\tstyleObjectToString: styleObjectToString,\n\tgetAttr: getAttr,\n\tsetAttr: setAttr,\n\tsafeInsert: safeInsert,\n\twalkAttrs: walkAttrs,\n\twalkNodes: walkNodes\n});\n\nvar styleNode;\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style');\n    setAttr(newNode, 'type', 'text/css');\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n    /* istanbul ignore next */\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    }\n    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\n    return newNode\n  })();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function(k) { return byName[k] })\n      .concat(remainder).join('\\n');\n    /* istanbul ignore next */\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n};\n\n/**\n * The riot template engine\n * @version v3.0.8\n */\n\nvar skipRegex = (function () { //eslint-disable-line no-unused-vars\n\n  var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n  var beforeReWords = [\n    'case',\n    'default',\n    'do',\n    'else',\n    'in',\n    'instanceof',\n    'prefix',\n    'return',\n    'typeof',\n    'void',\n    'yield'\n  ];\n\n  var wordsLastChar = beforeReWords.reduce(function (s, w) {\n    return s + w.slice(-1)\n  }, '');\n\n  var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n  var RE_VN_CHAR = /[$\\w]/;\n\n  function prev (code, pos) {\n    while (--pos >= 0 && /\\s/.test(code[pos])){  }\n    return pos\n  }\n\n  function _skipRegex (code, start) {\n\n    var re = /.*/g;\n    var pos = re.lastIndex = start++;\n    var match = re.exec(code)[0].match(RE_REGEX);\n\n    if (match) {\n      var next = pos + match[0].length;\n\n      pos = prev(code, pos);\n      var c = code[pos];\n\n      if (pos < 0 || ~beforeReChars.indexOf(c)) {\n        return next\n      }\n\n      if (c === '.') {\n\n        if (code[pos - 1] === '.') {\n          start = next;\n        }\n\n      } else if (c === '+' || c === '-') {\n\n        if (code[--pos] !== c ||\n            (pos = prev(code, pos)) < 0 ||\n            !RE_VN_CHAR.test(code[pos])) {\n          start = next;\n        }\n\n      } else if (~wordsLastChar.indexOf(c)) {\n\n        var end = pos + 1;\n\n        while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){  }\n        if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n          start = next;\n        }\n      }\n    }\n\n    return start\n  }\n\n  return _skipRegex\n\n})();\n\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\n/* istanbul ignore next */\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n    },\n\n    DEFAULT = '{ }';\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];\n\n    var qblocks = [];\n    var prevStr = '';\n    var mark, lastIndex;\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      lastIndex = re.lastIndex;\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n\n          var ch = match[2];\n          var rech = FINDBRACES[ch];\n          var ix = 1;\n\n          rech.lastIndex = lastIndex;\n          while ((match = rech.exec(str))) {\n            if (match[1]) {\n              if (match[1] === ch) { ++ix; }\n              else if (!--ix) { break }\n            } else {\n              rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n            }\n          }\n          re.lastIndex = ix ? str.length : rech.lastIndex;\n          continue\n        }\n\n        if (!match[3]) {\n          re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    parts.qblocks = qblocks;\n\n    return parts\n\n    function unescapeStr (s) {\n      if (prevStr) {\n        s = prevStr + s;\n        prevStr = '';\n      }\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n      if (slash) {\n        _lastIndex = skipRegex(str, _pos);\n      }\n\n      if (tmpl && _lastIndex > _pos + 2) {\n        mark = '\\u2057' + qblocks.length + '~';\n        qblocks.push(str.slice(_pos, _lastIndex));\n        prevStr += str.slice(start, _pos) + mark;\n        start = _lastIndex;\n      }\n      return _lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n  _brackets.skipRegex = skipRegex;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n  _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\n/* istanbul ignore next */\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(\n      data, _logErr.bind({\n        data: data,\n        tmpl: str\n      })\n    )\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.__ && ctx.__.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      console.error(err.message);\n      console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n      console.log(this.data); // eslint-disable-line\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var RE_DQUOTE = /\\u2057/g;\n  var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n    var qstr = parts.qblocks;\n    var expr;\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr.length) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n      .replace(/\\s+/g, ' ').trim()\n      .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.8';\n\n  return _tmpl\n\n})();\n\n/* istanbul ignore next */\nvar observable$1 = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n  var i = 0;\n  for (; i < len; ++i) {\n    fn(list[i], i);\n  }\n  return list\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments;\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\nvar misc = Object.freeze({\n\teach: each,\n\tcontains: contains,\n\ttoCamel: toCamel,\n\tstartsWith: startsWith,\n\tdefineProperty: defineProperty,\n\textend: extend\n});\n\nvar settings$1 = extend(Object.create(brackets.settings), {\n  skipAnonymousTags: true,\n  // handle the auto updates on any DOM event\n  autoUpdate: true\n});\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this.__.parent,\n    item = this.__.item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag.__.item;\n      ptag = ptag.__.parent;\n    } }\n\n  // override the event properties\n  /* istanbul ignore next */\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  // avoid auto updates\n  if (!settings$1.autoUpdate) { return }\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParentTag(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName,\n    cb = handleEvent.bind(tag, dom, handler);\n\n  // avoid to bind twice the same event\n  // possible fix for #2332\n  dom[name] = null;\n\n  // normalize event name\n  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n  // cache the listener into the listeners array\n  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n  dom[RIOT_EVENTS_KEY][name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag }    parent - parent for tag creation\n * @param { String } tagName - tag implementation we want to use\n */\nfunction updateDataIs(expr, parent, tagName) {\n  var conf, isVirtual, head, ref;\n\n  if (expr.tag && expr.tagName === tagName) {\n    expr.tag.update();\n    return\n  }\n\n  isVirtual = expr.dom.tagName === 'VIRTUAL';\n  // sync _parent to accommodate changing tagnames\n  if (expr.tag) {\n    // need placeholder before unmount\n    if(isVirtual) {\n      head = expr.tag.__.head;\n      ref = createDOMPlaceholder();\n      head.parentNode.insertBefore(ref, head);\n    }\n\n    expr.tag.unmount(true);\n  }\n\n  if (!isString(tagName)) { return }\n\n  expr.impl = __TAG_IMPL[tagName];\n  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n  each(expr.attrs, function (a) { return setAttr(expr.tag.root, a.name, a.value); });\n  expr.tagName = tagName;\n  expr.tag.mount();\n  if (isVirtual)\n    { makeReplaceVirtual(expr.tag, ref || expr.tag.root); } // root exist first time, after use placeholder\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.__.onUnmount = function() {\n    var delName = expr.tag.opts.dataIs,\n      tags = expr.tag.parent.tags,\n      _tags = expr.tag.__.parent.tags;\n    arrayishRemove(tags, delName, expr.tag);\n    arrayishRemove(_tags, delName, expr.tag);\n    expr.tag.unmount();\n  };\n}\n\n/**\n * Nomalize any attribute removing the \"riot-\" prefix\n * @param   { String } attrName - original attribute name\n * @returns { String } valid html attribute name\n */\nfunction normalizeAttrName(attrName) {\n  if (!attrName) { return null }\n  attrName = attrName.replace(ATTRS_PREFIX, '');\n  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n  return attrName\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  if (this.root && getAttr(this.root,'virtualized')) { return }\n\n  var dom = expr.dom,\n    // remove the riot- prefix\n    attrName = normalizeAttrName(expr.attr),\n    isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n    parent = dom && (expr.parent || dom.parentNode),\n    // detect the style attributes\n    isStyleAttr = attrName === 'style',\n    isClassAttr = attrName === 'class',\n    hasValue,\n    isObj,\n    value;\n\n  // if it's a tag we could totally skip the rest\n  if (expr._riot_id) {\n    if (expr.isMounted) {\n      expr.update();\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n      if (isVirtual) {\n        makeReplaceVirtual(expr, expr.root);\n      }\n    }\n    return\n  }\n  // if this expression has the update method it means it can handle the DOM changes by itself\n  if (expr.update) { return expr.update() }\n\n  // ...it seems to be a simple expression so we try to calculat its value\n  value = tmpl(expr.expr, isToggle ? extend({}, Object.create(this.parent), this) : this);\n  hasValue = !isBlank(value);\n  isObj = isObject(value);\n\n  // convert the style/class objects to strings\n  if (isObj) {\n    isObj = !isClassAttr && !isStyleAttr;\n    if (isClassAttr) {\n      value = tmpl(JSON.stringify(value), this);\n    } else if (isStyleAttr) {\n      value = styleObjectToString(value);\n    }\n  }\n\n  // remove original attribute\n  if (expr.attr && (!expr.isAttrRemoved || !hasValue || value === false)) {\n    remAttr(dom, expr.attr);\n    expr.isAttrRemoved = true;\n  }\n\n  // for the boolean attributes we don't need the value\n  // we can convert it to checked=true to checked=checked\n  if (expr.bool) { value = value ? attrName : false; }\n  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n  if (expr.wasParsedOnce && expr.value === value) { return }\n\n  // update the expression value\n  expr.value = value;\n  expr.wasParsedOnce = true;\n\n  // if the value is an object we can not do much more with it\n  if (isObj && !isToggle) { return }\n  // avoid to render undefined/null values\n  if (isBlank(value)) { value = ''; }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n  // handle attributes\n  } else {\n    if (expr.bool) {\n      dom[attrName] = value;\n    }\n\n    if (attrName === 'value' && dom.value !== value) {\n      dom.value = value;\n    }\n\n    if (hasValue && value !== false) {\n      setAttr(dom, attrName, value);\n    }\n\n    // make sure that in case of style changes\n    // the element stays hidden\n    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction updateAllExpressions(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\nvar IfExpr = {\n  init: function init(dom, tag, expr) {\n    remAttr(dom, CONDITIONAL_DIRECTIVE);\n    this.tag = tag;\n    this.expr = expr;\n    this.stub = createDOMPlaceholder();\n    this.pristine = dom;\n\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update() {\n    this.value = tmpl(this.expr, this.tag);\n\n    if (this.value && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n      this.expressions = [];\n      parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n    } else if (!this.value && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode) {\n        this.current.parentNode.removeChild(this.current);\n      }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (this.value) { updateAllExpressions.call(this.tag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n  }\n};\n\nvar RefExpr = {\n  init: function init(dom, parent, attrName, attrValue) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    return this\n  },\n  update: function update() {\n    var old = this.value;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n    if (!isBlank(this.value) && isString(this.value)) {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(\n        customParent.refs,\n        this.value,\n        tagOrDom,\n        // use an array if it's a looped node and the ref is not an expression\n        null,\n        this.parent.__.index\n      ); }\n\n      if (this.value !== old) {\n        setAttr(this.dom, this.attr, this.value);\n      }\n    } else {\n      remAttr(this.dom, this.attr);\n    }\n\n    // cache the ref bound to this dom node\n    // to reuse it in future (see also #2329)\n    if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n  }\n};\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? Object.create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n  var i = tags.length,\n    j = items.length;\n\n  while (i > j) {\n    i--;\n    remove.apply(tags[i], [tags, i]);\n  }\n}\n\n\n/**\n * Remove a child tag\n * @this Tag\n * @param   { Array } tags - tags collection\n * @param   { Number } i - index of the tag to remove\n */\nfunction remove(tags, i) {\n  tags.splice(i, 1);\n  this.unmount();\n  arrayishRemove(this.parent, this, this.__.tagName, true);\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    moveChildTag.apply(this$1.tags[tagName], [tagName, i]);\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, LOOP_DIRECTIVE);\n\n  var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE),\n    tagName = getTagName(dom),\n    impl = __TAG_IMPL[tagName],\n    parentNode = dom.parentNode,\n    placeholder = createDOMPlaceholder(),\n    child = getTag(dom),\n    ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE),\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isLoop = true,\n    isAnonymous = !__TAG_IMPL[tagName],\n    isVirtual = dom.tagName === 'VIRTUAL';\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { remAttr(dom, CONDITIONAL_DIRECTIVE); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(placeholder, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n    // get the new items collection\n    expr.value = tmpl(expr.val, parent);\n\n    var frag = createFrag(),\n      items = expr.value,\n      isObject$$1 = !isArray(items) && !isString(items),\n      root = placeholder.parentNode;\n\n    // if this DOM was removed the update here is useless\n    // this condition fixes also a weird async issue on IE in our unit test\n    if (!root) { return }\n\n    // object loop. any changes cause full redraw\n    if (isObject$$1) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, items[key], key)\n        }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function(item, i) {\n        if (expr.key && !isObject$$1)\n          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\n        return !!tmpl(ifExpr, extend(Object.create(parent), item))\n      });\n    }\n\n    // loop all the new items\n    each(items, function(item, i) {\n      // reorder only if the items are objects\n      var\n        doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        isNew = oldPos === -1,\n        pos = !isNew && doReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos],\n        mustAppend = i >= oldItems.length,\n        mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\n      // new tag\n      if (mustCreate) {\n        tag = new Tag$1(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          tagName: tagName,\n          root: dom.cloneNode(isAnonymous),\n          item: item,\n          index: i,\n        }, dom.innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n      } else if (pos !== i && doReorder) {\n        // move\n        if (contains(items, oldItems[pos])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n          // move the old tag instance\n          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n          // move the old item\n          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        }\n\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag.__.item = item;\n      tag.__.index = i;\n      tag.__.parent = parent;\n\n      if (!mustCreate) { tag.update(item); }\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags);\n\n    // clone the items array\n    oldItems = items.slice();\n\n    // this condition is weird u\n    root.insertBefore(frag, placeholder);\n  };\n\n  expr.unmount = function() {\n    each(tags, function(t) { t.unmount(); });\n  };\n\n  return expr\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Array } expressions - empty array where the expressions will be added\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Object } an object containing the root noode and the dom tree\n */\nfunction parseExpressions(root, expressions, mustIncludeRoot) {\n  var this$1 = this;\n\n  var tree = {parent: {children: expressions}};\n\n  walkNodes(root, function (dom, ctx) {\n    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return ctx } // not an element\n\n    var isVirtual = dom.tagName === 'VIRTUAL';\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n      if(isVirtual) { setAttr(dom, 'loopVirtual', true); } // ignore here, handled in _each\n      parent.children.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n      return false\n    }\n\n    if (expr = getAttr(dom, IS_DIRECTIVE)) {\n      if (tmpl.hasExpr(expr)) {\n        parent.children.push({isRtag: true, expr: expr, dom: dom, attrs: [].slice.call(dom.attributes)});\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = getTag(dom);\n    if(isVirtual) {\n      if(getAttr(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n      if(!tagImpl && !getAttr(dom, 'virtualized') && !getAttr(dom, 'loopVirtual'))  // ok to create virtual tag\n        { tagImpl = { tmpl: dom.outerHTML }; }\n    }\n\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      if(isVirtual && !getAttr(dom, IS_DIRECTIVE)) { // handled in update\n        // can not remove attribute like directives\n        // so flag for removal after creation to prevent maximum stack error\n        setAttr(dom, 'virtualized', true);\n\n        var tag = new Tag$1({ tmpl: dom.outerHTML },\n          {root: dom, parent: this$1},\n          dom.innerHTML);\n        parent.children.push(tag); // no return, anonymous tag, keep parsing\n      } else {\n        var conf = {root: dom, parent: this$1, hasImpl: true};\n        parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n        return false\n      }\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n      if (!expr) { return }\n      parent.children.push(expr);\n    }]);\n\n    // whatever the parent is, all child elements get the same parent.\n    // If this element had an if-attr, that's the parent for all child elements\n    return {parent: parent}\n  }, tree);\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    if (!attr) { return false }\n\n    var name = attr.name, bool = isBoolAttr(name), expr;\n\n    if (contains(REF_DIRECTIVES, name)) {\n      expr =  Object.create(RefExpr).init(dom, this$1, name, attr.value);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar reHasYield  = /<yield\\b/i;\nvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\nvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\nvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\nvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\nvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\nvar GENERIC = 'div';\nvar SVG = 'svg';\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  /* istanbul ignore next */\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @param   { Boolean } isSvg - true if the root node is an svg\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html, isSvg$$1) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n    tagName = match && match[1].toLowerCase(),\n    el = mkEl(isSvg$$1 ? SVG : GENERIC);\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl); }\n\n  return el\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag$2(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag$1(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mountTo(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag$1(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2$1(name, tmpl, css, attrs, fn) {\n  if (css) { styleManager.add(css, name); }\n\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount$1(selector, tagName, opts) {\n  var tags = [];\n  var elem, allTags;\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, IS_DIRECTIVE), tag;\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttr(root, IS_DIRECTIVE, tagName);\n      }\n\n      tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag)\n        { tags.push(tag); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = selectTags() :\n      // or just the ones named like the selector\n      selector + selectTags(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectTags();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar mixins_id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin$1(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin$1((\"__\" + (mixins_id++) + \"__\"), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error((\"Unregistered mixin: \" + name)) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n}\n\nfunction unregister$1(name) {\n  __TAG_IMPL[name] = null;\n}\n\nvar version$1 = 'v3.6.1';\n\n\nvar core = Object.freeze({\n\tTag: Tag$2,\n\ttag: tag$1,\n\ttag2: tag2$1,\n\tmount: mount$1,\n\tmixin: mixin$1,\n\tupdate: update$1,\n\tunregister: unregister$1,\n\tversion: version$1\n});\n\n// counter to give a unique id to all the Tag instances\nvar __uid = 0;\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n\n  var ctx = !isAnonymous && isLoop ? this : parent || this;\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n    // normalize the attribute names\n    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n\n/**\n * Tag class\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction Tag$1(impl, conf, innerHTML) {\n  if ( impl === void 0 ) impl = {};\n  if ( conf === void 0 ) conf = {};\n\n  var opts = extend({}, conf.opts),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    isAnonymous = !!conf.isAnonymous,\n    skipAnonymous = settings$1.skipAnonymousTags && isAnonymous,\n    item = cleanUpData(conf.item),\n    index = conf.index, // available only for the looped nodes\n    instAttrs = [], // All attributes on the Tag when it's first parsed\n    implAttrs = [], // expressions on this type of Tag\n    expressions = [],\n    root = conf.root,\n    tagName = conf.tagName || getTagName(root),\n    isVirtual = tagName === 'virtual',\n    isInline = !isVirtual && !impl.tmpl,\n    propsInSyncWithParent = [],\n    dom;\n\n  // make this tag observable\n  if (!skipAnonymous) { observable$1(this); }\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  this.isMounted = false;\n\n  defineProperty(this, '__', {\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    tagName: tagName,\n    index: index,\n    isLoop: isLoop,\n    isInline: isInline,\n    // tags having event listeners\n    // it would be better to use weak maps here but we can not introduce breaking changes now\n    listeners: [],\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    tail: null,\n    head: null,\n    parent: null,\n    item: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n  defineProperty(this, 'root', root);\n  extend(this, { opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  defineProperty(this, 'parent', parent || null);\n  defineProperty(this, 'tags', {});\n  defineProperty(this, 'refs', {});\n\n  if (isInline || isLoop && isAnonymous) {\n    dom = root;\n  } else {\n    if (!isVirtual) { root.innerHTML = ''; }\n    dom = mkdom(impl.tmpl, innerHTML, isSvg(root));\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'update', function tagUpdate(data) {\n    var nextOpts = {},\n      canTrigger = this.isMounted && !skipAnonymous;\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data);\n    extend(this, data);\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, nextOpts, instAttrs]);\n\n    if (canTrigger && this.isMounted && isFunction(this.shouldUpdate) && !this.shouldUpdate(data, nextOpts)) {\n      return this\n    }\n\n    // inherit properties from the parent, but only for isAnonymous tags\n    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n    extend(opts, nextOpts);\n    if (canTrigger) { this.trigger('update', data); }\n    updateAllExpressions.call(this, expressions);\n    if (canTrigger) { this.trigger('updated'); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mixin', function tagMixin() {\n    var this$1 = this;\n\n    each(arguments, function (mix) {\n      var instance, obj;\n      var props = [];\n\n      // properties blacklisted and will not be bound to the tag instance\n      var propsBlacklist = ['init', '__proto__'];\n\n      mix = isString(mix) ? mixin$1(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to this\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(this$1, key, descriptor);\n          } else {\n            this$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(this$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(this$1)(); }\n    });\n    return this\n  }.bind(this));\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mount', function tagMount() {\n    var this$1 = this;\n\n    root._tag = this; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n      attr.expr = expr;\n      instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    implAttrs = [];\n    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttr(root, attr.name, attr.value); }\n    }]);\n\n    // initialiation\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin$1(GLOBAL_MIXIN);\n\n    if (globalMixin && !skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          this$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (impl.fn) { impl.fn.call(this, opts); }\n\n    if (!skipAnonymous) { this.trigger('before-mount'); }\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions.apply(this, [dom, expressions, isAnonymous]);\n\n    this.update(item);\n\n    if (!isAnonymous && !isInline) {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n    }\n\n    defineProperty(this, 'root', root);\n    defineProperty(this, 'isMounted', true);\n\n    if (skipAnonymous) { return }\n\n    // if it's not a child tag we can trigger its mount event\n    if (!this.parent) {\n      this.trigger('mount');\n    }\n    // otherwise we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n    else {\n      var p = getImmediateCustomParentTag(this.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        this$1.trigger('mount');\n      });\n    }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n    var this$1 = this;\n\n    var el = this.root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __TAGS_CACHE.indexOf(this);\n\n    if (!skipAnonymous) { this.trigger('before-unmount'); }\n\n    // clear all attributes coming from the mounted tag\n    walkAttrs(impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX))\n        { name = name.slice(ATTRS_PREFIX.length); }\n\n      remAttr(root, name);\n    });\n\n    // remove all the event listeners\n    this.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    });\n\n    // remove this tag instance from the global virtualDom variable\n    if (tagIndex !== -1)\n      { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    if (p || isVirtual) {\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent);\n\n        if (isVirtual) {\n          Object.keys(this.tags).forEach(function (tagName) {\n            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n          });\n        } else {\n          arrayishRemove(ptag.tags, tagName, this);\n          // remove from _parent too\n          if(parent !== ptag) {\n            arrayishRemove(parent.tags, tagName, this);\n          }\n        }\n      } else {\n        // remove the tag contents\n        setInnerHTML(el, '');\n      }\n\n      if (p && !mustKeepRoot) { p.removeChild(el); }\n    }\n\n    if (this.__.virts) {\n      each(this.__.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    // custom internal unmount function to avoid relying on the observable\n    if (this.__.onUnmount) { this.__.onUnmount(); }\n\n    if (!skipAnonymous) {\n      this.trigger('unmount');\n      this.off('*');\n    }\n\n    defineProperty(this, 'isMounted', false);\n\n    delete this.root._tag;\n\n    return this\n\n  }.bind(this));\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) ||\n    getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Inherit properties from a target tag instance\n * @this Tag\n * @param   { Tag } target - tag where we will inherit properties\n * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n */\nfunction inheritFrom(target, propsInSyncWithParent) {\n  var this$1 = this;\n\n  each(Object.keys(target), function (k) {\n    // some properties must be always in sync with the parent tag\n    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\n    if (isUndefined(this$1[k]) || mustSync) {\n      // track the property to keep in sync\n      // so we can keep it updated\n      if (!mustSync) { propsInSyncWithParent.push(k); }\n      this$1[k] = target[k];\n    }\n  });\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tagName, newPos) {\n  var parent = this.parent,\n    tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag$1(child, opts, innerHTML),\n    tagName = opts.tagName || getTagName(opts.root, true),\n    ptag = getImmediateCustomParentTag(parent);\n  // fix for the parent attribute in the looped elements\n  defineProperty(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag.__.parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag;\n  while (ptag.__.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function(expr) {\n    if (expr instanceof Tag$1) { expr.unmount(true); }\n    else if (expr.tagName) { expr.tag.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom, skipDataIs) {\n  var child = getTag(dom),\n    namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag$1) && !(data && isFunction(data.trigger)))\n    { return data }\n\n  var o = {};\n  for (var key in data) {\n    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n  }\n  return o\n}\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n * @param { Number } index - add the new item in a certain array position\n */\nfunction arrayishAdd(obj, key, value, ensureArray, index) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n  var hasIndex = !isUndefined(index);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else {\n    if (isArr) {\n      var oldIndex = dest.indexOf(value);\n      // this item never changed its position\n      if (oldIndex === index) { return }\n      // remove the item from its old position\n      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n      // move or add the item\n      if (hasIndex) {\n        dest.splice(index, 0, value);\n      } else {\n        dest.push(value);\n      }\n    } else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    var index = obj[key].indexOf(value);\n    if (index !== -1) { obj[key].splice(index, 1); }\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName],\n    implClass = __TAG_IMPL[tagName].class,\n    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\n  var conf = extend({ root: root, opts: opts }, { parent: opts ? opts.parent : null });\n\n  if (impl && root) { Tag$1.apply(tag, [impl, conf, innerHTML]); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n/**\n * makes a tag virtual and replaces a reference in the dom\n * @this Tag\n * @param { tag } the tag to make virtual\n * @param { ref } the dom reference location\n */\nfunction makeReplaceVirtual(tag, ref) {\n  var frag = createFrag();\n  makeVirtual.call(tag, frag);\n  ref.parentNode.replaceChild(frag, ref);\n}\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder(),\n    tail = createDOMPlaceholder(),\n    frag = createFrag(),\n    sib, el;\n\n  this.root.insertBefore(head, this.root.firstChild);\n  this.root.appendChild(tail);\n\n  this.__.head = el = head;\n  this.__.tail = tail;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1.__.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target.__.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this.__.head,\n    frag = createFrag(),\n    sib;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1.__.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target.__.head);\n      break\n    }\n  }\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction selectTags(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + selectTags(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n\nvar tags = Object.freeze({\n\tgetTag: getTag,\n\tinheritFrom: inheritFrom,\n\tmoveChildTag: moveChildTag,\n\tinitChildTag: initChildTag,\n\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\tunmountAll: unmountAll,\n\tgetTagName: getTagName,\n\tcleanUpData: cleanUpData,\n\tarrayishAdd: arrayishAdd,\n\tarrayishRemove: arrayishRemove,\n\tmountTo: mountTo,\n\tmakeReplaceVirtual: makeReplaceVirtual,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tselectTags: selectTags\n});\n\n/**\n * Riot public api\n */\nvar settings = settings$1;\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\n// export the core props/methods\nvar Tag$$1 = Tag$2;\nvar tag$$1 = tag$1;\nvar tag2$$1 = tag2$1;\nvar mount$$1 = mount$1;\nvar mixin$$1 = mixin$1;\nvar update$$1 = update$1;\nvar unregister$$1 = unregister$1;\nvar version$$1 = version$1;\nvar observable = observable$1;\n\nvar riot$1 = extend({}, core, {\n  observable: observable$1,\n  settings: settings,\n  util: util,\n});\n\nexports.settings = settings;\nexports.util = util;\nexports.Tag = Tag$$1;\nexports.tag = tag$$1;\nexports.tag2 = tag2$$1;\nexports.mount = mount$$1;\nexports.mixin = mixin$$1;\nexports.update = update$$1;\nexports.unregister = unregister$$1;\nexports.version = version$$1;\nexports.observable = observable;\nexports['default'] = riot$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot/riot.js\n// module id = 1\n// module chunks = 0","const topIndustries = require('dsv!../data/top_industries.csv')\nconst smamuIndustries = require('dsv!../data/smamu_industries.csv')\nconst smamuGroups = require('json!../data/smamu_groups.json')\nconst industryStories = require('json!../data/industry_stories.json')\n\nmodule.exports = {\n  topIndustries,\n  smamuIndustries,\n  smamuGroups,\n  industryStories\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/scripts/data.js","riot.tag2('stacked-barh', '<div class=\"{getClass(\\'bar-outer\\', opts.modifier)}\"> <div each=\"{opts.data}\" class=\"{getClass(\\'bar\\', modifier)}\" riot-style=\"width:{value}%;\"> <span class=\"{getClass(\\'bar__label\\', modifier)}\">{label}</span> </div> </div>', '', 'class=\"{getClass()}\"', function(opts) {\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/div-bars/stacked-barh.tag","import './stacked-barh.tag'\n\nriot.tag2('stacked-barhs', '<div class=\"{getClass(\\'legend\\')}\"> <div each=\"{label, i in opts.legend}\" class=\"{getClass(\\'legend__item\\', parent.opts.modifiers[i])}\"><span></span>{label} </div> </div> <div each=\"{data in opts.data}\" class=\"{getClass(\\'container\\')}\"> <span class=\"{getClass(\\'label\\')}\">{data[parent.opts.barlabels]}</span> <span class=\"{getClass(\\'sub-label\\')}\">Besch√§ftigte insgesamt: {_f(+data.gb_t + +data.svb_t)}</span> <stacked-barh data=\"{parent.getData(data)}\" css=\"stacked-barh\"></stacked-barh> </div> <div class=\"{getClass(\\'legend\\')}\"> <div each=\"{label, i in opts.legend}\" class=\"{getClass(\\'legend__item\\', parent.opts.modifiers[i])}\"><span></span>{label} </div> </div>', '', 'class=\"{getClass()}\"', function(opts) {\n\n  this.getData = data => this.opts.cols.map((c, i) => {\n    const value = data[c]\n    return {\n      value,\n      label: this.opts.labelformat(value),\n      modifier: this.opts.modifiers[i]\n    }\n  })\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/div-bars/stacked-barhs.tag","import {topIndustries} from '../scripts/data.js'\nimport './div-bars/stacked-barhs.tag'\n\nriot.tag2('cor-mj-industries-main', '<stacked-barhs ref=\"stacked-barhs\" data=\"{data}\" barlabels=\"name\" labelformat=\"{labelformat}\" cols=\"{[\\'gb_t_rel\\', \\'svb_t_rel\\']}\" modifiers=\"{[\\'gb\\', \\'svb\\']}\" legend=\"{[\\'Minijobs\\', \\'sozialversicherungspflichtig\\']}\"></stacked-barhs> <section class=\"{getClass(\\'annotation\\')}\"> Die angegebenen Prozentwerte beziehen sich jeweils auf die Summe der Menschen, die in Minijobs und sozialversicherungspflichtigen Besch√§ftigungen arbeiten. </section>', '', 'class=\"{getClass(\\'viz-section\\')}\"', function(opts) {\n\n  this.data = topIndustries.sort((a, b) => b.gb_t_rel - a.gb_t_rel)\n  this.labelformat = v => this._f(v) + ' %'\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/industries-main.tag","import {smamuIndustries} from '../scripts/data.js'\nimport './industry-chart/industry-chart.tag'\n\nriot.tag2('cor-mj-industries-multi-charts', '<industry-chart each=\"{data in data}\" data=\"{data}\" css=\"industry-chart\"></industry-chart>', '', 'class=\"{getClass(\\'viz-section\\')}\"', function(opts) {\n\n  this.data = smamuIndustries\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/industries-multi-charts.tag","import {smamuGroups, industryStories} from '../../scripts/data.js'\nimport '../div-bars/stacked-barh.tag'\n\nriot.tag2('industry-chart', '<h3 class=\"{getClass(\\'title\\')}\">{opts.data.name}</h3> <p class=\"{getClass(\\'description\\')}\">{getDesc(opts.data.name)}</p> <div class=\"{getClass(\\'charts-wrapper\\')}\"> <div each=\"{group in groups}\" class=\"{getClass(\\'chart\\')}\"> <h4 class=\"{getClass(\\'chart__label\\')}\">{group.title}</h4> <div class=\"{getClass(\\'chart__bars-container\\')}\"> <div each=\"{suffix, i in [\\'gb\\', \\'svb\\']}\" class=\"{getClass(\\'chart__stacked-barh\\', suffix)}\"> <span if=\"{!i}\" class=\"{getClass(\\'chart__stacked-barh__label\\')}\"> {labels[i]}: <strong>{getValue(group, suffix )}&nbsp;%</strong> </span> <stacked-barh data=\"{parent.parent.getData(group, suffix)}\" modifier=\"{group.field}\" css=\"stacked-barh\"></stacked-barh> <span if=\"{i}\" class=\"{getClass(\\'chart__stacked-barh__label\\')}\"> {labels[i]}: <strong>{getValue(group, suffix )}&nbsp;%</strong> </span> </div> </div> </div> </div>', '', 'class=\"{getClass()}\"', function(opts) {\n\n  this.groups = smamuGroups\n  this.labels = ['Minijobs', 'SV-Besch√§ftigungen']\n  this.getDesc = name => industryStories[name]\n  this.getValue = ({field}, suffix) => +this.opts.data[`${suffix}_${field}`]\n  this.getData = ({field}, suffix) => {\n    const value = this.getValue({field}, suffix)\n    return [value, 100-value].map((val, i) => {\n      return {\n        value: val,\n        // label: this._f(val) + ' %',\n        modifier: ['full', 'empty'][i]\n      }\n    })\n  }\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/industry-chart/industry-chart.tag","'use strict'\n\nif (module.hot) {\n  module.hot.accept()\n}\n\n// import 'babel-polyfill'\nimport '../styles/index.scss'\n\n// mixins\nimport getClass from './mixins/class_name.js'\nimport numberFormat from './mixins/number_format.js'\nriot.mixin(getClass('mjid'))\nriot.mixin(numberFormat)\n\n// mount vizes\nimport '../components/industries-main.tag'\nimport '../components/industries-multi-charts.tag'\n\nconst mount = (name) => {\n  const selector = `[data-riot-mount=\"${name}\"]`\n  riot.mount(selector, name)\n}\n\nmount('cor-mj-industries-main')\nmount('cor-mj-industries-multi-charts')\n\n\n\n// WEBPACK FOOTER //\n// ./src/scripts/index.js","export {\n  format,\n  formatLocale,\n} from 'd3-format'\n\n\n\n// WEBPACK FOOTER //\n// ./src/scripts/lib/d3.js","// riot mixin for computing class names\n//\n// it takes a global `cssNamespace` on init that becomes prefix for all classes.\n//\n// components can have the `ref`-attribute set to append this (say, the name for this component) to the\n// global prefix\n//\n// components then have `this.getClass` that computes the acutal class name for something, e.g:\n//    global namespace is 'foo', components ref-attr is 'bar', then\n//      `getClass('title')` results in a class named 'foo-bar__title'\n//     if ref is undefined, `getClass('title')` becomes 'foo-title'\n\nexport default cssNamespace => {\n  return {\n    getClass: function(name, mod=null) {\n      const ref = this.opts.ref || this.opts.css\n      const part = ref ? `${cssNamespace}-${ref}` : false\n      const cssClass = name ?\n        part ? `${part}__${name}` : `${cssNamespace}-${name}`\n        : part\n      return mod ? `${cssClass} ${cssClass}--${mod}` : cssClass\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/scripts/mixins/class_name.js","// riot mixin for formatting numbers to german locale\nimport * as d3 from '../lib/d3.js'\n\nconst loc = d3.formatLocale({\n  thousands: '.',\n  decimal: ',',\n  grouping: [3]\n})\n\nconst format = loc.format(',')\n\nmodule.exports = {_f: val => val && format(val)}\n\n\n\n// WEBPACK FOOTER //\n// ./src/scripts/mixins/number_format.js","// https://d3js.org/d3-format/ Version 1.2.0. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimal(1.23) returns [\"123\", 0].\nvar formatDecimal = function(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ¬±Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n};\n\nvar exponent = function(x) {\n  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n};\n\nvar formatGroup = function(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n};\n\nvar formatNumerals = function(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n};\n\nvar formatDefault = function(x, p) {\n  x = x.toPrecision(p);\n\n  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (x[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      case \"e\": break out;\n      default: if (i0 > 0) i0 = 0; break;\n    }\n  }\n\n  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n};\n\nvar prefixExponent;\n\nvar formatPrefixAuto = function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n};\n\nvar formatRounded = function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n};\n\nvar formatTypes = {\n  \"\": formatDefault,\n  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n  \"b\": function(x) { return Math.round(x).toString(2); },\n  \"c\": function(x) { return x + \"\"; },\n  \"d\": function(x) { return Math.round(x).toString(10); },\n  \"e\": function(x, p) { return x.toExponential(p); },\n  \"f\": function(x, p) { return x.toFixed(p); },\n  \"g\": function(x, p) { return x.toPrecision(p); },\n  \"o\": function(x) { return Math.round(x).toString(8); },\n  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n  \"x\": function(x) { return Math.round(x).toString(16); }\n};\n\n// [[fill]align][sign][symbol][0][width][,][.precision][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\nfunction formatSpecifier(specifier) {\n  return new FormatSpecifier(specifier);\n}\n\nformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\nfunction FormatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n  var match,\n      fill = match[1] || \" \",\n      align = match[2] || \">\",\n      sign = match[3] || \"-\",\n      symbol = match[4] || \"\",\n      zero = !!match[5],\n      width = match[6] && +match[6],\n      comma = !!match[7],\n      precision = match[8] && +match[8].slice(1),\n      type = match[9] || \"\";\n\n  // The \"n\" type is an alias for \",g\".\n  if (type === \"n\") comma = true, type = \"g\";\n\n  // Map invalid types to the default format.\n  else if (!formatTypes[type]) type = \"\";\n\n  // If zero fill is specified, padding goes after sign and before digits.\n  if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n  this.fill = fill;\n  this.align = align;\n  this.sign = sign;\n  this.symbol = symbol;\n  this.zero = zero;\n  this.width = width;\n  this.comma = comma;\n  this.precision = precision;\n  this.type = type;\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + this.type;\n};\n\nvar identity = function(x) {\n  return x;\n};\n\nvar prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"¬µ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nvar formatLocale = function(locale) {\n  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n      currency = locale.currency,\n      decimal = locale.decimal,\n      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,\n      percent = locale.percent || \"%\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        type = specifier.type;\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = !type || /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision == null ? (type ? 6 : 12)\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Perform the initial formatting.\n        var valueNegative = value < 0;\n        value = formatType(Math.abs(value), precision);\n\n        // If a negative value rounds to zero during formatting, treat as positive.\n        if (valueNegative && +value === 0) valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer ‚Äúvalue‚Äù part that can be\n        // grouped, and fractional or exponential ‚Äúsuffix‚Äù part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n};\n\nvar locale;\n\n\n\ndefaultLocale({\n  decimal: \".\",\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\n\nfunction defaultLocale(definition) {\n  locale = formatLocale(definition);\n  exports.format = locale.format;\n  exports.formatPrefix = locale.formatPrefix;\n  return locale;\n}\n\nvar precisionFixed = function(step) {\n  return Math.max(0, -exponent(Math.abs(step)));\n};\n\nvar precisionPrefix = function(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n};\n\nvar precisionRound = function(step, max) {\n  step = Math.abs(step), max = Math.abs(max) - step;\n  return Math.max(0, exponent(max) - exponent(step)) + 1;\n};\n\nexports.formatDefaultLocale = defaultLocale;\nexports.formatLocale = formatLocale;\nexports.formatSpecifier = formatSpecifier;\nexports.precisionFixed = precisionFixed;\nexports.precisionPrefix = precisionPrefix;\nexports.precisionRound = precisionRound;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3-format/build/d3-format.js\n// module id = 12\n// module chunks = 0","var res = [{\"name\":\"Einzelhandel (ohne KFZ)\",\"svb_f\":\"70.4\",\"gb_f\":\"71.5\",\"svb_foreign\":\"8.1\",\"gb_foreign\":\"8.3\",\"svb_assistant\":\"8.8\",\"gb_assistant\":\"44.3\",\"svb_education\":\"26.3\",\"gb_education\":\"47.7\"},{\"name\":\"Gastronomie\",\"svb_f\":\"52.3\",\"gb_f\":\"62.4\",\"svb_foreign\":\"33.2\",\"gb_foreign\":\"18.0\",\"svb_assistant\":\"34.5\",\"gb_assistant\":\"44.5\",\"svb_education\":\"51.7\",\"gb_education\":\"54.8\"},{\"name\":\"Geb√§udebetreuung, Garten- und Landschaftsbau\",\"svb_f\":\"53.4\",\"gb_f\":\"63.3\",\"svb_foreign\":\"27.9\",\"gb_foreign\":\"31.9\",\"svb_assistant\":\"54.5\",\"gb_assistant\":\"75.4\",\"svb_education\":\"54.5\",\"gb_education\":\"60.7\"},{\"name\":\"Gesundheitswesen\",\"svb_f\":\"81.0\",\"gb_f\":\"78.4\",\"svb_foreign\":\"5.7\",\"gb_foreign\":\"7.2\",\"svb_assistant\":\"7.2\",\"gb_assistant\":\"37.6\",\"svb_education\":\"13.0\",\"gb_education\":\"30.0\"},{\"name\":\"Private Haushalte mit Hauspersonal\",\"svb_f\":\"86.8\",\"gb_f\":\"89.5\",\"svb_foreign\":\"27.3\",\"gb_foreign\":\"15.5\",\"svb_assistant\":\"59.9\",\"gb_assistant\":\"39.9\",\"svb_education\":\"42.6\",\"gb_education\":\"66.4\"},{\"name\":\"Baustellenarbeiten, Bauinstallation etc.\",\"svb_f\":\"14.2\",\"gb_f\":\"42.7\",\"svb_foreign\":\"11.6\",\"gb_foreign\":\"9.2\",\"svb_assistant\":\"13.5\",\"gb_assistant\":\"49.1\",\"svb_education\":\"26.7\",\"gb_education\":\"31.7\"}];res.columns = [\"name\",\"svb_f\",\"gb_f\",\"svb_foreign\",\"gb_foreign\",\"svb_assistant\",\"gb_assistant\",\"svb_education\",\"gb_education\"];module.exports = res;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dsv-loader!./src/data/smamu_industries.csv\n// module id = 13\n// module chunks = 0","var res = [{\"name\":\"Einzelhandel (ohne KFZ)\",\"svb_t_relv\":\"7.5\",\"gb_t_relv\":\"12.1\",\"svb_t_rel\":\"71.9\",\"gb_t_rel\":\"28.1\",\"svb_t\":\"2351156\",\"gb_t\":\"918810\"},{\"name\":\"Gastronomie\",\"svb_t_relv\":\"2.2\",\"gb_t_relv\":\"10.2\",\"svb_t_rel\":\"47.2\",\"gb_t_rel\":\"52.8\",\"svb_t\":\"689904\",\"gb_t\":\"772007\"},{\"name\":\"Geb√§udebetreuung, Garten- und Landschaftsbau\",\"svb_t_relv\":\"2.2\",\"gb_t_relv\":\"7.8\",\"svb_t_rel\":\"54.3\",\"gb_t_rel\":\"45.7\",\"svb_t\":\"699630\",\"gb_t\":\"589605\"},{\"name\":\"Gesundheitswesen\",\"svb_t_relv\":\"7.5\",\"gb_t_relv\":\"5.7\",\"svb_t_rel\":\"84.4\",\"gb_t_rel\":\"15.6\",\"svb_t\":\"2350181\",\"gb_t\":\"432831\"},{\"name\":\"Private Haushalte mit Hauspersonal\",\"svb_t_relv\":\"0.1\",\"gb_t_relv\":\"3.7\",\"svb_t_rel\":\"14.4\",\"gb_t_rel\":\"85.6\",\"svb_t\":\"46541\",\"gb_t\":\"276737\"},{\"name\":\"Baustellenarbeiten, Bauinstallation etc.\",\"svb_t_relv\":\"3.9\",\"gb_t_relv\":\"3.3\",\"svb_t_rel\":\"83.0\",\"gb_t_rel\":\"17.0\",\"svb_t\":\"1224092\",\"gb_t\":\"250757\"}];res.columns = [\"name\",\"svb_t_relv\",\"gb_t_relv\",\"svb_t_rel\",\"gb_t_rel\",\"svb_t\",\"gb_t\"];module.exports = res;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dsv-loader!./src/data/top_industries.csv\n// module id = 14\n// module chunks = 0","module.exports = {\n\t\"Einzelhandel (ohne KFZ)\": \"Im Einzelhandel arbeiten mit √ºber 900.000 die meisten Minijobber im Vergleich mit anderen Branchen. Rund f√ºnf mal so viele Minijobs im Einzelhandel haben das niedrigste Anforderungsniveau (Helfer) als in regul√§ren Jobs. Auch der Anteil der Minijobber, die keine oder eine unbekannte Berufsbildung haben, ist hier fast doppelt so hoch.\",\n\t\"Gastronomie\": \"Die Gastronomie ist eine klassische Minijobber-Branche, rund die H√§lfte aller Arbeitenden hier sind geringf√ºgig besch√§ftigt. Interessant: In sozialversicherungspflichtigen Anstellungen arbeiten hier mit gut 33 Prozent knapp doppelt so viele Menschen ohne deutsche Staatsb√ºrgerschaft wie in Minijobs.\",\n\t\"Geb√§udebetreuung, Garten- und Landschaftsbau\": \"Hierzu geh√∂ren vor allem Hausmeister- und Reinigungsdienste. In keiner anderen der gro√üen Branchen arbeiten so viele Menschen ohne Berufsabschluss und in der niedrigsten Anforderungsstufe (als Helfer), sowohl in Minijobs als auch sozialversicherungspflichtigen Besch√§ftigungen.\",\n\t\"Gesundheitswesen\": \"Die meisten der gut 430.000 Minijobber im Gesundheitswesen arbeiten als Helfer in Arztpraxen. Das erkl√§rt den hohen Anteil des Helfer-Anforderungsniveaus: Verglichen mit regul√§ren Anstellungsverh√§ltnissen ist hier der Anteil rund f√ºnf mal h√∂her.\",\n\t\"Private Haushalte mit Hauspersonal\": \"In keiner anderen Branche arbeiten anteilsm√§√üig so viele Frauen: Fast neun von zehn Minijobber sind hier weiblich. Jedoch arbeiten in sozialversicherungspflichtigen Verh√§ltnissen anderthalb mal so viele \\\"Helfer\\\" als in geringf√ºgigen.\",\n\t\"Baustellenarbeiten, Bauinstallation etc.\": \"Die meisten der 250.000 Minijobber arbeiten hier in der Elektroinstallation, D√§mmung und Klempnerarbeiten. In keiner anderen der hier vorgestellten Branchen ist der Frauenanteil so gering ‚Äì jedoch ausgerechnet bei den Minijobbern deutlich h√∂her als in regul√§ren Besch√§ftigungsverh√§ltnissen.\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./src/data/industry_stories.json\n// module id = 16\n// module chunks = 0","module.exports = [\n\t{\n\t\t\"title\": \"Frauenanteil\",\n\t\t\"field\": \"f\"\n\t},\n\t{\n\t\t\"title\": \"Ausl√§nderanteil\",\n\t\t\"field\": \"foreign\"\n\t},\n\t{\n\t\t\"title\": \"Anforderungsniveau: Anteil Helfer\",\n\t\t\"field\": \"assistant\"\n\t},\n\t{\n\t\t\"title\": \"Keine oder unbekannte Berufsbildung\",\n\t\t\"field\": \"education\"\n\t}\n];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./src/data/smamu_groups.json\n// module id = 17\n// module chunks = 0"],"sourceRoot":""}